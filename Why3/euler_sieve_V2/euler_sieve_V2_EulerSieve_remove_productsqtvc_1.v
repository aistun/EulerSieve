(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require int.ComputerDivision.
Require map.Map.
Require number.Parity.
Require number.Divisibility.
Require number.Prime.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z < (length self))%Z \/ (0%Z = (length self)).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom mixfix_lblsmnrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((length (mixfix_lblsmnrb a1 i v)) = (length a1)) /\
  (let result := elts (mixfix_lblsmnrb a1 i v) in
   forall (y:Numbers.BinNums.Z),
   ((y = i) -> ((result y) = v)) /\ (~ (y = i) -> ((result y) = (elts a1 y)))).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z < n)%Z \/ (0%Z = n) ->
  (forall (i:Numbers.BinNums.Z), ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < n)%Z ->
   ((elts (make n v) i) = v)) /\
  ((length (make n v)) = n).

Axiom mult_croissance_locale :
  forall (n:Numbers.BinNums.Z) (a:Numbers.BinNums.Z),
  (0%Z < n)%Z /\ ((0%Z < a)%Z \/ (0%Z = a)) ->
  ((n * a)%Z < (n * (a + 1%Z)%Z)%Z)%Z.

Axiom mult_croissance :
  forall (n:Numbers.BinNums.Z) (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z),
  (0%Z < n)%Z /\ ((0%Z < a)%Z \/ (0%Z = a)) /\ (a < b)%Z ->
  ((n * a)%Z < (n * b)%Z)%Z.

Axiom comp_mult_2 :
  forall (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z),
  (0%Z < n)%Z /\ ((2%Z < k)%Z \/ (2%Z = k)) ->
  ((n * 2%Z)%Z < (n * k)%Z)%Z \/ ((n * 2%Z)%Z = (n * k)%Z).

Axiom div_croissance_locale1 :
  forall (i:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (0%Z < n)%Z ->
  ((int.EuclideanDivision.div i n) <
   (int.EuclideanDivision.div (i + 1%Z)%Z n))%Z \/
  ((int.EuclideanDivision.div i n) =
   (int.EuclideanDivision.div (i + 1%Z)%Z n)).

Axiom div_croissance1 :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (((0%Z < i)%Z \/ (0%Z = i)) /\ ((i < j)%Z \/ (i = j))) /\ (0%Z < n)%Z ->
  ((int.EuclideanDivision.div i n) < (int.EuclideanDivision.div j n))%Z \/
  ((int.EuclideanDivision.div i n) = (int.EuclideanDivision.div j n)).

Axiom div_croissance_locale2 :
  forall (m:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z < i)%Z /\ ((0%Z < m)%Z \/ (0%Z = m)) ->
  ((int.EuclideanDivision.div m (i + 1%Z)%Z) <
   (int.EuclideanDivision.div m i))%Z \/
  ((int.EuclideanDivision.div m (i + 1%Z)%Z) =
   (int.EuclideanDivision.div m i)).

Axiom div_croissance2 :
  forall (m:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  ((0%Z < i)%Z /\ ((i < j)%Z \/ (i = j))) /\ ((0%Z < m)%Z \/ (0%Z = m)) ->
  ((int.EuclideanDivision.div m j) < (int.EuclideanDivision.div m i))%Z \/
  ((int.EuclideanDivision.div m j) = (int.EuclideanDivision.div m i)).

Axiom div_mult_1 :
  forall (n:Numbers.BinNums.Z) (k:Numbers.BinNums.Z) (max:Numbers.BinNums.Z),
  (0%Z < n)%Z /\
  ((n < max)%Z \/ (n = max)) /\ (((n * k)%Z < max)%Z \/ ((n * k)%Z = max)) ->
  (k = (int.EuclideanDivision.div (n * k)%Z n)) /\
  (((int.EuclideanDivision.div (n * k)%Z n) <
    (int.EuclideanDivision.div max n))%Z \/
   ((int.EuclideanDivision.div (n * k)%Z n) =
    (int.EuclideanDivision.div max n))).

Axiom mult_borne_sous_exp :
  forall (n:Numbers.BinNums.Z) (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z),
  ((1%Z < a)%Z \/ (1%Z = a)) /\
  ((1%Z < b)%Z \/ (1%Z = b)) /\
  ((1%Z < n)%Z \/ (1%Z = n)) /\ ((a * b)%Z < n)%Z -> (a < n)%Z /\ (b < n)%Z.

Axiom divides_div :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (k:Numbers.BinNums.Z),
  ((2%Z < n)%Z \/ (2%Z = n)) /\
  ((2%Z < m)%Z \/ (2%Z = m)) /\
  (((2%Z < k)%Z \/ (2%Z = k)) /\ (k < n)%Z) /\
  ((n = 0%Z) /\ (m = 0%Z) \/
   ~ (n = 0%Z) /\ ((ZArith.BinInt.Z.rem m n) = 0%Z)) /\
  ~ (((k = 0%Z) -> (m = 0%Z)) /\
     (~ (k = 0%Z) -> ((ZArith.BinInt.Z.rem m k) = 0%Z))) ->
  ~ ((k = 0%Z) /\ ((int.EuclideanDivision.div m n) = 0%Z) \/
     ~ (k = 0%Z) /\
     ((ZArith.BinInt.Z.rem (int.EuclideanDivision.div m n) k) = 0%Z)).

Axiom divides_inf :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  ((2%Z < n)%Z \/ (2%Z = n)) /\
  ((2%Z < m)%Z \/ (2%Z = m)) /\
  ((n = 0%Z) /\ (m = 0%Z) \/
   ~ (n = 0%Z) /\ ((ZArith.BinInt.Z.rem m n) = 0%Z)) /\
  (forall (k:Numbers.BinNums.Z), ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < n)%Z ->
   ~ (((k = 0%Z) -> (m = 0%Z)) /\
      (~ (k = 0%Z) -> ((ZArith.BinInt.Z.rem m k) = 0%Z)))) ->
  forall (k:Numbers.BinNums.Z), ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < n)%Z ->
  ~ ((k = 0%Z) /\ ((int.EuclideanDivision.div m n) = 0%Z) \/
     ~ (k = 0%Z) /\
     ((ZArith.BinInt.Z.rem (int.EuclideanDivision.div m n) k) = 0%Z)).

Axiom conservation_inv_marked_nexts_on_marked_change :
  forall (marked:array Init.Datatypes.bool) (nexts:array Numbers.BinNums.Z),
  ((length marked) = (length nexts)) ->
  ((length marked) = (length nexts)) /\
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
   (forall (j:Numbers.BinNums.Z), (i < j)%Z /\ (j < (elts nexts i))%Z ->
    ((elts marked j) = Init.Datatypes.true))) ->
  forall (i:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
  ((length (mixfix_lblsmnrb marked i Init.Datatypes.true)) = (length nexts)) /\
  (forall (i1:Numbers.BinNums.Z),
   ((0%Z < i1)%Z \/ (0%Z = i1)) /\
   (i1 < (length (mixfix_lblsmnrb marked i Init.Datatypes.true)))%Z ->
   (forall (j:Numbers.BinNums.Z), (i1 < j)%Z /\ (j < (elts nexts i1))%Z ->
    ((elts (mixfix_lblsmnrb marked i Init.Datatypes.true) j) =
     Init.Datatypes.true))).

Axiom conservation_inv_marked_nexts_on_nexts_change :
  forall (marked:array Init.Datatypes.bool) (nexts:array Numbers.BinNums.Z),
  ((length marked) = (length nexts)) ->
  ((length marked) = (length nexts)) /\
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
   (forall (j:Numbers.BinNums.Z), (i < j)%Z /\ (j < (elts nexts i))%Z ->
    ((elts marked j) = Init.Datatypes.true))) ->
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
   (i < (elts nexts i))%Z /\
   (((elts nexts i) < (length marked))%Z \/
    ((elts nexts i) = (length marked)))) ->
  ~ ((elts marked 2%Z) = Init.Datatypes.true) ->
  forall (i:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
  ~ ((elts nexts i) = (length marked)) ->
  ((elts marked (elts nexts i)) = Init.Datatypes.true) ->
  ((length marked) =
   (length (mixfix_lblsmnrb nexts i (elts nexts (elts nexts i))))) /\
  (forall (i1:Numbers.BinNums.Z),
   ((0%Z < i1)%Z \/ (0%Z = i1)) /\ (i1 < (length marked))%Z ->
   (forall (j:Numbers.BinNums.Z),
    (i1 < j)%Z /\
    (j < (elts (mixfix_lblsmnrb nexts i (elts nexts (elts nexts i))) i1))%Z ->
    ((elts marked j) = Init.Datatypes.true))).

Axiom a :
  forall (marked:array Init.Datatypes.bool) (n:Numbers.BinNums.Z),
  ((2%Z < n)%Z \/ (2%Z = n)) /\
  ((n < (length marked))%Z \/ (n = (length marked))) ->
  (forall (i:Numbers.BinNums.Z), ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z ->
   (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (length marked))%Z) /\
   (forall (k:Numbers.BinNums.Z),
    ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked))%Z ->
    ((i * k)%Z < (length marked))%Z ->
    ((elts marked (i * k)%Z) = Init.Datatypes.true))) ->
  forall (k:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < n)%Z ->
  ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (length marked))%Z ->
  ((k * i)%Z < (length marked))%Z -> forall (j:Numbers.BinNums.Z),
  ((1%Z < j)%Z \/ (1%Z = j)) /\ (j < (length marked))%Z ->
  (((k * i)%Z * j)%Z < (length marked))%Z ->
  ((elts marked ((k * i)%Z * j)%Z) = Init.Datatypes.true).

Axiom prev_and_new_impl_all_products_marked :
  forall (marked_old:array Init.Datatypes.bool)
    (marked:array Init.Datatypes.bool) (n:Numbers.BinNums.Z)
    (max:Numbers.BinNums.Z),
  (((2%Z < n)%Z \/ (2%Z = n)) /\ (n < (length marked))%Z) /\
  (((2%Z < max)%Z \/ (2%Z = max)) /\ (max < (length marked))%Z) /\
  ((length marked_old) = (length marked)) ->
  ((length marked) = (length marked_old)) /\
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
   ~ ((elts marked i) = Init.Datatypes.true) ->
   ~ ((elts marked_old i) = Init.Datatypes.true)) ->
  (forall (i:Numbers.BinNums.Z), ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z ->
   (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (length marked_old))%Z) /\
   (forall (k:Numbers.BinNums.Z),
    ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked_old))%Z ->
    ((i * k)%Z < (length marked_old))%Z ->
    ((elts marked_old (i * k)%Z) = Init.Datatypes.true))) ->
  (forall (i:Numbers.BinNums.Z), ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z ->
   (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (length marked))%Z) /\
   (forall (k:Numbers.BinNums.Z),
    ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked))%Z ->
    ((i * k)%Z < (length marked))%Z ->
    ((elts marked (i * k)%Z) = Init.Datatypes.true))) ->
  (forall (k:Numbers.BinNums.Z),
   ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked_old))%Z ->
   ((elts marked_old k) = Init.Datatypes.true) ->
   (exists i:Numbers.BinNums.Z, exists j:Numbers.BinNums.Z,
    (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z) /\
    (((2%Z < j)%Z \/ (2%Z = j)) /\ (j < (length marked_old))%Z) /\
    ((i * j)%Z = k))) ->
  ((length marked_old) = (length marked)) /\
  (n < (length marked))%Z /\
  (forall (i:Numbers.BinNums.Z),
   ((n < i)%Z \/ (n = i)) /\ (i < (length marked))%Z ->
   ~ ((elts marked_old i) = Init.Datatypes.true) ->
   ((n * i)%Z < (length marked_old))%Z ->
   ((elts marked (n * i)%Z) = Init.Datatypes.true)) ->
  (((2%Z < n)%Z \/ (2%Z = n)) /\ (n < (length marked))%Z) /\
  (forall (k:Numbers.BinNums.Z),
   ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked))%Z ->
   ((n * k)%Z < (length marked))%Z ->
   ((elts marked (n * k)%Z) = Init.Datatypes.true)).

Axiom conservation_previously_marked_products_on_marked_change :
  forall (marked:array Init.Datatypes.bool) (n:Numbers.BinNums.Z),
  (forall (i:Numbers.BinNums.Z), ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z ->
   (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (length marked))%Z) /\
   (forall (k:Numbers.BinNums.Z),
    ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked))%Z ->
    ((i * k)%Z < (length marked))%Z ->
    ((elts marked (i * k)%Z) = Init.Datatypes.true))) ->
  forall (i:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
  forall (i1:Numbers.BinNums.Z),
  ((2%Z < i1)%Z \/ (2%Z = i1)) /\ (i1 < n)%Z ->
  (((2%Z < i1)%Z \/ (2%Z = i1)) /\
   (i1 < (length (mixfix_lblsmnrb marked i Init.Datatypes.true)))%Z) /\
  (forall (k:Numbers.BinNums.Z),
   ((2%Z < k)%Z \/ (2%Z = k)) /\
   (k < (length (mixfix_lblsmnrb marked i Init.Datatypes.true)))%Z ->
   ((i1 * k)%Z < (length (mixfix_lblsmnrb marked i Init.Datatypes.true)))%Z ->
   ((elts (mixfix_lblsmnrb marked i Init.Datatypes.true) (i1 * k)%Z) =
    Init.Datatypes.true)).

Axiom conservation_inv_marked_old_nexts2 :
  forall (marked:array Init.Datatypes.bool) (nexts:array Numbers.BinNums.Z)
    (max:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (((length marked) = (length nexts)) /\
   ((2%Z < (length marked))%Z \/ (2%Z = (length marked))) /\
   ((2%Z < n)%Z \/ (2%Z = n)) /\
   (forall (i:Numbers.BinNums.Z),
    ((2%Z < i)%Z \/ (2%Z = i)) /\
    ((i < (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))%Z \/
     (i = (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))) ->
    ((elts nexts i) <
     (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))%Z \/
    ((elts nexts i) =
     (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n)) ->
    ~ ((elts marked i) = Init.Datatypes.true) ->
    ~ ((elts marked (elts nexts i)) = Init.Datatypes.true))) /\
  ((n < (elts nexts n))%Z /\ (0%Z < n)%Z) /\
  (((int.EuclideanDivision.div max (elts nexts n)) <
    (int.EuclideanDivision.div max n))%Z \/
   ((int.EuclideanDivision.div max (elts nexts n)) =
    (int.EuclideanDivision.div max n))) ->
  ((length marked) = (length nexts)) /\
  ((2%Z < (length marked))%Z \/ (2%Z = (length marked))) /\
  ((2%Z < (elts nexts n))%Z \/ (2%Z = (elts nexts n))) /\
  (forall (i:Numbers.BinNums.Z),
   ((2%Z < i)%Z \/ (2%Z = i)) /\
   ((i <
     (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z
      (elts nexts n)))%Z \/
    (i =
     (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z
      (elts nexts n)))) ->
   ((elts nexts i) <
    (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z (elts nexts n)))%Z \/
   ((elts nexts i) =
    (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z (elts nexts n))) ->
   ~ ((elts marked i) = Init.Datatypes.true) ->
   ~ ((elts marked (elts nexts i)) = Init.Datatypes.true)).

Parameter nexts: array Numbers.BinNums.Z.

Parameter marked: array Init.Datatypes.bool.

Parameter max: Numbers.BinNums.Z.

Parameter n: Numbers.BinNums.Z.

Axiom H : (2%Z < n)%Z \/ (2%Z = n).

Axiom H1 : (n < max)%Z \/ (n = max).

Axiom H2 : ((n * n)%Z < max)%Z \/ ((n * n)%Z = max).

Axiom H3 : ((length nexts) = (length marked)).

Axiom H4 : ((length marked) = (max + 1%Z)%Z).

Axiom Requires :
  ((length nexts) = (length marked)) /\
  ~ ((elts marked 2%Z) = Init.Datatypes.true) /\
  (forall (i:Numbers.BinNums.Z), ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < n)%Z ->
   (~ ((elts marked i) = Init.Datatypes.true) ->
    ((2%Z < i)%Z \/ (2%Z = i)) /\
    (forall (n1:Numbers.BinNums.Z), (1%Z < n1)%Z /\ (n1 < i)%Z ->
     ~ ((n1 = 0%Z) /\ (i = 0%Z) \/
        ~ (n1 = 0%Z) /\ ((ZArith.BinInt.Z.rem i n1) = 0%Z)))) /\
   (((2%Z < i)%Z \/ (2%Z = i)) /\
    (forall (n1:Numbers.BinNums.Z), (1%Z < n1)%Z /\ (n1 < i)%Z ->
     ~ (((n1 = 0%Z) -> (i = 0%Z)) /\
        (~ (n1 = 0%Z) -> ((ZArith.BinInt.Z.rem i n1) = 0%Z)))) ->
    ~ ((elts marked i) = Init.Datatypes.true))) /\
  (((2%Z < n)%Z \/ (2%Z = n)) /\
   (forall (n1:Numbers.BinNums.Z), (1%Z < n1)%Z /\ (n1 < n)%Z ->
    ~ ((n1 = 0%Z) /\ (n = 0%Z) \/
       ~ (n1 = 0%Z) /\ ((ZArith.BinInt.Z.rem n n1) = 0%Z)))) /\
  ~ ((elts marked n) = Init.Datatypes.true) /\
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length nexts))%Z ->
   (i < (elts nexts i))%Z /\
   (((elts nexts i) < (length nexts))%Z \/ ((elts nexts i) = (length nexts)))).

Axiom Requires1 :
  forall (i:Numbers.BinNums.Z), ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z ->
  (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (length marked))%Z) /\
  (forall (k:Numbers.BinNums.Z),
   ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked))%Z ->
   ((i * k)%Z < (length marked))%Z ->
   ((elts marked (i * k)%Z) = Init.Datatypes.true)).

Axiom Requires2 :
  forall (k:Numbers.BinNums.Z),
  ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked))%Z ->
  ((elts marked k) = Init.Datatypes.true) ->
  exists i:Numbers.BinNums.Z, exists j:Numbers.BinNums.Z,
  (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z) /\
  (((2%Z < j)%Z \/ (2%Z = j)) /\ (j < (length marked))%Z) /\ ((i * j)%Z = k).

Axiom Requires3 :
  ((length marked) = (length nexts)) /\
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked))%Z ->
   (forall (j:Numbers.BinNums.Z), (i < j)%Z /\ (j < (elts nexts i))%Z ->
    ((elts marked j) = Init.Datatypes.true))).

Axiom Requires4 :
  ((length marked) = (length nexts)) /\
  ((2%Z < (length marked))%Z \/ (2%Z = (length marked))) /\
  ((2%Z < n)%Z \/ (2%Z = n)) /\
  (forall (i:Numbers.BinNums.Z),
   ((2%Z < i)%Z \/ (2%Z = i)) /\
   ((i < (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))%Z \/
    (i = (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))) ->
   ((elts nexts i) <
    (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))%Z \/
   ((elts nexts i) =
    (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n)) ->
   ~ ((elts marked i) = Init.Datatypes.true) ->
   ~ ((elts marked (elts nexts i)) = Init.Datatypes.true)).

Parameter marked_old: array Init.Datatypes.bool.

Axiom Ensures : ((length marked_old) = (length marked)).

Axiom Ensures1 :
  forall (i:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked_old))%Z ->
  ((elts marked_old i) = (elts marked i)).

Axiom Assert :
  ((length marked_old) = (length nexts)) /\
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length marked_old))%Z ->
   (forall (j:Numbers.BinNums.Z), (i < j)%Z /\ (j < (elts nexts i))%Z ->
    ((elts marked_old j) = Init.Datatypes.true))).

Axiom Assert1 :
  ((length marked_old) = (length nexts)) /\
  ((2%Z < (length marked_old))%Z \/ (2%Z = (length marked_old))) /\
  ((2%Z < n)%Z \/ (2%Z = n)) /\
  (forall (i:Numbers.BinNums.Z),
   ((2%Z < i)%Z \/ (2%Z = i)) /\
   ((i < (int.EuclideanDivision.div ((length marked_old) + (-1%Z)%Z)%Z n))%Z \/
    (i = (int.EuclideanDivision.div ((length marked_old) + (-1%Z)%Z)%Z n))) ->
   ((elts nexts i) <
    (int.EuclideanDivision.div ((length marked_old) + (-1%Z)%Z)%Z n))%Z \/
   ((elts nexts i) =
    (int.EuclideanDivision.div ((length marked_old) + (-1%Z)%Z)%Z n)) ->
   ~ ((elts marked_old i) = Init.Datatypes.true) ->
   ~ ((elts marked_old (elts nexts i)) = Init.Datatypes.true)).

Axiom H5 :
  ((length marked) = (length nexts)) /\
  ((2%Z < (length marked))%Z \/ (2%Z = (length marked))) /\
  ((2%Z < n)%Z \/ (2%Z = n)) /\
  ((n < (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))%Z \/
   (n = (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))) /\
  (forall (i:Numbers.BinNums.Z), ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z ->
   ((elts nexts i) <
    (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n))%Z \/
   ((elts nexts i) =
    (int.EuclideanDivision.div ((length marked) + (-1%Z)%Z)%Z n)) ->
   ~ ((elts marked i) = Init.Datatypes.true) ->
   ~ ((elts marked (elts nexts i)) = Init.Datatypes.true)).

Axiom Assert2 :
  forall (i:Numbers.BinNums.Z), ((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z ->
  (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (length marked_old))%Z) /\
  (forall (k:Numbers.BinNums.Z),
   ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked_old))%Z ->
   ((i * k)%Z < (length marked_old))%Z ->
   ((elts marked_old (i * k)%Z) = Init.Datatypes.true)).

Axiom Assert3 :
  forall (k:Numbers.BinNums.Z),
  ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked_old))%Z ->
  ((elts marked_old k) = Init.Datatypes.true) ->
  exists i:Numbers.BinNums.Z, exists j:Numbers.BinNums.Z,
  (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < n)%Z) /\
  (((2%Z < j)%Z \/ (2%Z = j)) /\ (j < (length marked_old))%Z) /\
  ((i * j)%Z = k).

Parameter marked1: array Init.Datatypes.bool.

Axiom H6 : ((length marked1) = (length marked)).

Axiom Ensures2 :
  let result := elts marked1 in
  forall (y:Numbers.BinNums.Z),
  ((y = (n * n)%Z) -> ((result y) = Init.Datatypes.true)) /\
  (~ (y = (n * n)%Z) -> ((result y) = (elts marked y))).

Axiom Ensures3 :
  (marked1 = (mixfix_lblsmnrb marked (n * n)%Z Init.Datatypes.true)).

Axiom Assert4 :
  forall (i:Numbers.BinNums.Z), ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < n)%Z ->
  ~ ((elts nexts i) = (n * n)%Z).

Axiom H7 : (n < (elts nexts n))%Z.

Axiom H8 :
  ((elts nexts n) < (length marked1))%Z \/
  ((elts nexts n) = (length marked1)).

(* Why3 goal *)
Theorem remove_products'vc :
  forall (k:Numbers.BinNums.Z),
  ((2%Z < k)%Z \/ (2%Z = k)) /\ (k < (length marked1))%Z ->
  ((elts marked1 k) = Init.Datatypes.true) ->
  exists i:Numbers.BinNums.Z, exists j:Numbers.BinNums.Z,
  (((2%Z < i)%Z \/ (2%Z = i)) /\ (i < (elts nexts n))%Z) /\
  (((2%Z < j)%Z \/ (2%Z = j)) /\ (j < (length marked1))%Z) /\ ((i * j)%Z = k).
Proof.
intros k (h1,h2) h3.

Qed.

