module EulerSieve

use int.Int
use array.Array

let rec remove_products (nexts: array int) (marked: array bool)
                        (max: int) (n: int) (p: int) : unit
= let next = if p = -1 then n else nexts[p] in
  if next <> -1 then
    if n * next <= max then begin
      marked[n * next] <- true;
      if p <> -1 && marked[next] then begin
        nexts[p] <- nexts[next];
        remove_products nexts marked max n p
      end else
        remove_products nexts marked max n next
    end

let rec euler_sieve (max: int) : array int
= let nexts = make (max + 1) (-1) in
  let marked = make (max + 1) false in
  for i = 0 to max - 1 do
     nexts[i] <- i + 1
  done;
  let rec loop n =
     if n <> -1 then begin
       remove_products nexts marked max n (-1);
       loop nexts[n]
     end in
  loop 2;
  let rec count p cnt =
    let next = nexts[p] in
    if next = -1 then cnt
    else
      if marked[next] then begin
        nexts[p] <- nexts[next];
        count p cnt
      end else
        count next (cnt + 1) in
  let primes = make (count 1 0) 0 in
  let ref p = 0 in
  let ref i = 2 in
  while i <> -1 do
    if not marked[i] then begin
      primes[p] <- i;
      p <- p + 1
    end;
    i <- nexts[i]
  done;
  primes

end
