module EulerSieve

use int.Int
use number.Divisibility
use number.Prime
use array.Array

predicate inv_nexts (nexts: array int) (n: int) =
  forall i. 0 <= i < n ->
            i < nexts[i] <= n

predicate all_primes (marked: array bool) (n: int) =
  forall i. 0 <= i < n -> not marked[i] <-> prime i
  
(*
  Note intéressante :
  -------------------
  Je pense que ...
  La seule implication à démontrer est que tous les nombres non marqués
  sont premiers !
  Car à chaque fois qu'on marque un nombre, par définition, c'est qu'il est
  produit de deux entiers (nécessairement compris entre 2 et inférieurs au
  nombre marqué). ET DONC, ça nous donne directement l'implication 
  marked[i] -> not prime i, ce qui nous donne donc prime i -> not marked[i] !
  Et donc tous les nombres premiers inférieures ou égaux à n seront 
  nécessairement marqués !
*)

predicate inv_remove_products (nexts: array int) (marked: array bool) (n: int) =
  nexts.length = marked.length /\
  not marked[2] /\
  all_primes marked n /\
  prime n /\
  inv_nexts nexts nexts.length

predicate inv_count (nexts: array int) (marked: array bool) (min: int) =
  nexts.length = marked.length /\
  forall i. min <= i < nexts.length ->
            i < nexts[i] <= nexts.length


predicate same_elements (a1: array 'a) (a2: array 'a) (n: int) =
  forall k. 0 <= k < n -> a1[k] = a2[k]

predicate all_differents (a: array 'a) (n: int) =
  forall i j. 0 <= i < j < n -> a[i] <> a[j]
  
predicate all_inf_or_eq (a: array int) (n k: int) =
  forall i. 0 <= i < n -> a[i] <= k

let remove_products (nexts: array int) (marked: array bool)
                        (max: int) (n: int) : unit
  requires { 2 <= n <= max }
  requires { nexts.length = marked.length = max + 1 }
  requires { inv_remove_products nexts marked n }
  ensures { inv_remove_products nexts marked n }
  = let rec loop p =
      requires { 1 <= p <= max }
      requires { 2 <= n <= max }
      requires { inv_remove_products nexts marked n }
      ensures { inv_remove_products nexts marked n }
      variant { max - nexts[p] }
      let next = nexts[p] in
      if 0 <= next < max + 1 then
        if n * next <= max then begin
          marked[n * next] <- true;
          if marked[next] then begin
            nexts[p] <- nexts[next];
            assert { next >= 2 };
            loop p
          end else
            loop next
        end in
      if n * n <= max then begin
        marked[n * n] <- true;
        loop n
      end  

let euler_sieve (max: int) : array int
  requires { max >= 2 }
  ensures { all_differents result result.length }
= let nexts = make (max + 1) 0 in
  let marked = make (max + 1) false in
  for i = 0 to max do
    invariant { inv_nexts nexts i }
    nexts[i] <- i + 1;
    (* assert { forall j. 0 <= j < i + 1 -> j < nexts[j] <= i + 1 } *)
  done;
  let rec loop n =
    requires { 2 <= n <= max + 1 } 
    requires { inv_remove_products nexts marked n }
    ensures { inv_remove_products nexts marked nexts.length }
    variant { max + 1 - n }
    if n <> max + 1 then begin
      remove_products nexts marked max n;
      loop nexts[n]
    end in
  loop 2;
  let rec count (p: int) (cnt: int) =
    requires { 2 <= p <= max }
    requires { 1 <= cnt <= p - 1 }
    requires { inv_count nexts marked cnt }
    requires { all_differents nexts cnt }
    requires { all_inf_or_eq nexts cnt p }
    ensures { 1 <= result <= max }
    ensures { all_differents nexts result }
    variant { max + 1 - nexts[p] }
    let next = nexts[p] in
    if next = max + 1 then begin nexts[cnt] <- 0; cnt end
    else
      if marked[next] then begin
        nexts[p] <- nexts[next];
        count p cnt
      end else begin
        (* 
           Attention : des fois j'ai des bonnes idées ! ...
           On réécrit le début du tableau nexts !
           Parce que le nombre de nombres premiers <= n est strictement inférieur à n !
           Du coup on peut réécrire le tableau nexts en recopiant consécutivement
           les nombres premiers déja rencontrés et ceci ne modifiera pas les calculs 
           de count par la suite 
        *)
        nexts[cnt] <- next; (* une opération en plus ... *)
        (* assert { all_differents nexts cnt }; *)
        (* assert { cnt + 1 <= p < p + 1 /\ all_inf_or_eq nexts cnt nexts[p] }; *)
        count next (cnt + 1)
      end in
  nexts[0] <- 2;
  sub nexts 0 (count 2 1)

end
