module ArithmeticResults

  use int.Int
  use number.Divisibility
  use number.Prime
  use int.EuclideanDivision

  let lemma mult_croissance_locale (n a: int)
    requires { n > 0 /\ 0 <= a }
    ensures { n * a < n * (a + 1) } = ()

  let rec lemma mult_croissance (n a b: int)
    requires { n > 0 /\ 0 <= a < b }
    ensures { n * a < n * b }
    variant { b - a }
    = if a + 1 = b then ()
      else mult_croissance n (a + 1) b

  let lemma comp_mult_2 (n k: int)
    requires { n > 0 /\ k >= 2 }
    ensures { n * k >= n * 2 } = ()

  let lemma div_croissance_locale1 (i n: int)
    requires { 0 <= i /\ n > 0 }
    ensures { div i n <= div (i + 1) n } = ()

  let rec lemma div_croissance1 (i j n: int)
    requires { 0 <= i <= j /\ n > 0 }
    ensures { div i n <= div j n }
    variant { j - i }
    = if i < j then
        div_croissance1 i (j - 1) n

  let rec lemma div_croissance_locale2 (m i: int)
    requires { i > 0 /\ m >= 0 }
    ensures { div m (i + 1) <= div m i }
    variant { m }
    = if m > 0 then div_croissance_locale2 (m - 1) i

  let rec lemma div_croissance2 (m i j: int)
    requires { 0 < i <= j /\ m >= 0 }
    ensures { div m i >= div m j }
    variant { j - i }
    = if i < j then div_croissance2 m i (j - 1)

  let lemma div_mult_1 (n k max: int)
    requires { n > 0 /\ max >= n /\ n * k <= max }
    ensures { k = div (n * k) n <= div max n } = ()

  let lemma mult_borne_sous_exp (n a b: int)
    requires { a >= 1 /\ b >= 1 /\ n >= 1 /\ a * b < n }
    ensures { a < n /\ b < n } = ()

  let rec lemma sq_ineq (a b: int)
    requires { a >= 0 /\ b >= 0 }
    requires { a * a < b * b }
    ensures { a < b }
    variant { b * b - a * a }
    = if (b - 1) * (b - 1) > a * a then
        sq_ineq a (b - 1)

end

module DivisibilityResults

  use int.Int
  use int.EuclideanDivision
  use number.Divisibility
  use number.Prime

  let lemma divides_div (n m k: int)
    requires { 2 <= n /\ 2 <= m /\ 2 <= k < n /\ divides n m /\ not divides k m }
    ensures { not divides k (div m n) } = ()

  let lemma divides_inf (n m: int)
    requires { 2 <= n /\ 2 <= m /\ divides n m /\
               forall k. 2 <= k < n -> not divides k m }
    ensures { forall k. 2 <= k < n -> not divides k (div m n) } = ()

  let lemma not_prime_divider_limits (n: int)
    requires { not prime n /\ 2 <= n }
    ensures { exists i. 2 <= i /\ i * i <= n /\ divides i n } = ()

  let lemma no_prod_impl_no_divider (n: int)
    requires { n >= 0 }
    ensures { forall i.
                2 <= i < n * n ->
                not (exists k l. 2 <= k < n /\ 2 <= l < i /\ k * l = i ) ->
                not (exists k. 2 <= k < n /\ k <> i /\ divides k i) } = ()

  use ArithmeticResults

  let lemma not_prime_impl_divisor_under_sqrt (n: int)
    requires { n >= 2 }
    ensures { forall i.
                2 <= i < n * n ->
                not prime i ->
                exists j. 2 <= j < i /\ ((j < n) by j * j < n * n /\ j >= 0) /\
                          divides j i } = ()

end

module EulerSieveSpec

  use int.Int
  use number.Divisibility
  use number.Prime
  use seq.Seq
  use int.EuclideanDivision

  use ArithmeticResults
  use DivisibilityResults


(*******************************************************************************)
(*                                                                             *)
(*         INVARIANTS SUR LES RELATIONS ENTRE STRUCTURES DE DONNEES            *)
(*                                                                             *)
(*******************************************************************************)

  predicate inv_nexts (nexts: seq int) (n: int) =
    forall i. 0 <= i < n ->
              i < nexts[i] <= n

  predicate inv_marked_nexts (marked: seq bool)
                             (nexts: seq int) =
    marked.length = nexts.length /\
    forall i. 0 <= i < marked.length ->
              forall j. i < j < nexts[i] ->
                        marked[j]

  predicate inv_marked_old_nexts1 (marked_old: seq bool)
                                  (nexts: seq int)
                                  (min: int) =
    marked_old.length = nexts.length /\
    forall i. min <= i < marked_old.length ->
              forall j. i < j < nexts[i] ->
                        marked_old[j]

  predicate inv_marked_old_nexts2 (marked_old: seq bool)
                                  (nexts: seq int)
                                  (n: int) =
    marked_old.length = nexts.length /\
    marked_old.length >= 2 /\
    n >= 2 /\
    forall i. 2 <= i <= div (marked_old.length - 1) n ->
              nexts[i] <= div (marked_old.length - 1) n ->
              not marked_old[i] ->
              not marked_old[nexts[i]]

  predicate inv_marked_marked_old (marked: seq bool)
                                  (marked_old: seq bool) =
    marked.length = marked_old.length /\
    forall i. 0 <= i < marked.length ->
              not marked[i] ->
              not marked_old[i]

  predicate inv_marked_old_nexts2_partial (marked_old: seq bool)
                                          (nexts: seq int)
                                          (n: int)
                                          (p: int) =
    marked_old.length = nexts.length /\
    marked_old.length >= 2 /\
    n >= 2 /\
    p <= div (marked_old.length - 1) n /\
    forall i. 2 <= i < p ->
              nexts[i] <= div (marked_old.length - 1) n ->
              not marked_old[i] ->
              not marked_old[nexts[i]]


(*******************************************************************************)
(*                                                                             *)
(*                   PROPRIETES LIEES AUX NOMBRES PREMIERS                     *)
(*                                                                             *)
(*******************************************************************************)

  predicate all_primes (marked: seq bool) (n: int) =
    forall i. 0 <= i < n -> not marked[i] <-> prime i

  predicate all_products_marked (marked: seq bool) (i max: int) =
    2 <= i < marked.length /\
    forall k. 2 <= k < max ->
              i * k < marked.length ->
              marked[i * k]

  predicate previously_marked_products (marked: seq bool) (n: int) =
    forall i. 2 <= i < n ->
              all_products_marked marked i marked.length

  predicate only_products_marked (marked: seq bool) (n: int) =
    forall k. 2 <= k < marked.length ->
              marked[k] ->
              exists i j. 2 <= i < n /\ 2 <= j < marked.length /\ i * j = k

  predicate prime_products_marked (marked_old: seq bool)
                                  (marked: seq bool)
                                  (n max: int) =
    marked_old.length = marked.length /\
    n < max <= marked.length /\
    forall i. n <= i < max ->
              not marked_old[i] ->
              n * i < marked_old.length ->
              marked[n * i]

  predicate inv_remove_products (nexts: seq int)
                                (marked: seq bool)
                                (n: int) =
    nexts.length = marked.length /\
    not marked[2] /\
    all_primes marked n /\
    prime n /\
    not marked[n] /\
    inv_nexts nexts nexts.length


(*******************************************************************************)
(*                                                                             *)
(*             QUELQUES LEMMES DE CONSERVATION DES STRUCTURES                  *)
(*                                                                             *)
(*******************************************************************************)


  let lemma conservation_inv_marked_nexts_on_marked_change (marked: seq bool)
                                                           (nexts: seq int)
                                                           (i: int)
    requires { marked.length = nexts.length }
    requires { inv_nexts nexts nexts.length }
    requires { inv_marked_nexts marked nexts }
    requires { 0 <= i < marked.length }
    ensures  { inv_marked_nexts marked[i <- true] nexts } = ()

  let lemma conservation_inv_marked_nexts_on_nexts_change (marked: seq bool)
                                                          (nexts: seq int)
                                                          (i v: int)
    requires { marked.length = nexts.length }
    requires { inv_marked_nexts marked nexts }
    requires { inv_nexts nexts marked.length }
    (* requires { not marked[2] } *)
    requires { 0 <= i < marked.length }
    requires { i < v <= marked.length }
    requires { forall j. i < j < v -> marked[j] }
    ensures  { inv_marked_nexts marked nexts[i <- v] } = ()

(*******************************************************************************)
(*                                                                             *)
(*                         QUELQUES PREDICATS UTILES                           *)
(*                                                                             *)
(*******************************************************************************)

  use array.Array

  predicate all_differents (a: array 'a) (n: int) =
    forall i j. 0 <= i < j < n -> a[i] <> a[j]

  predicate all_inf_or_eq (a: array int) (n k: int) =
    forall i. 0 <= i < n -> a[i] <= k

end

module EulerSieve

  use int.Int
  use number.Divisibility
  use number.Prime
  use seq.Seq
  use int.EuclideanDivision

  use ArithmeticResults
  use DivisibilityResults

  use EulerSieveSpec


  (* lemma conservation_inv_marked_nexts_on_nexts_change: *)
  (*   forall marked nexts. *)
  (*     marked.length = nexts.length -> *)
  (*     inv_marked_nexts marked nexts -> *)
  (*     inv_nexts nexts marked.length -> *)
  (*     not marked[2] -> *)
  (*     forall i. 0 <= i < marked.length -> *)
  (*               nexts[i] <> marked.length -> *)
  (*               marked[nexts[i]] -> *)
  (*               inv_marked_nexts marked nexts[i <- nexts[nexts[i]]] *)


(*******************************************************************************)
(*                                                                             *)
(*                   PROPRIETES LIEES AUX NOMBRES PREMIERS                     *)
(*                                                                             *)
(*******************************************************************************)

  let lemma marked_impl_all_products_marked (marked: seq bool) (n: int)
    requires { 2 <= n <= marked.length }
    requires { previously_marked_products marked n }
    ensures { forall k i.
                2 <= k < n ->
                2 <= i < marked.length ->
                k * i < marked.length ->
                forall j.
                  1 <= j < marked.length ->
                  k * i * j < marked.length ->
                  (marked[k * i * j] by
                    1 <= i * j < marked.length by
                    k >= 2 /\ i >= 2 /\ j >= 1 /\ k * (i * j) < marked.length) }
    = ()

  let lemma prev_and_new_impl_all_products_marked (marked_old marked: seq bool)
                                                  (n max: int)
    requires { 2 <= n < marked.length /\ 2 <= max < marked.length /\
               marked_old.length = marked.length }
    requires { inv_marked_marked_old marked marked_old }
    requires { previously_marked_products marked_old n }
    requires { previously_marked_products marked n }
    requires { only_products_marked marked_old n }
    requires { prime_products_marked marked_old marked n marked.length }
    ensures { all_products_marked marked n marked.length } =
    assert { (forall i. 2 <= i < n /\ 2 <= i < marked.length ->
                        not marked_old[i] ->
                        i * n < marked.length ->
                        marked[i * n]) by
             previously_marked_products marked n };
    assert { forall k. 2 <= k < marked_old.length ->
                       marked_old[k] ->
                       n * k < marked_old.length ->
                       exists i j. 2 <= i < n /\ 2 <= j < marked_old.length /\
                                   i * j = k /\ marked_old[i * j] };
    marked_impl_all_products_marked marked_old n;
    marked_impl_all_products_marked marked n;
    assert { marked.length = marked_old.length };
    assert { forall k. 2 <= k < marked_old.length ->
                       marked_old[k] ->
                       n * k < marked_old.length ->
                       marked[k * n] by
             forall k. 2 <= k < marked_old.length ->
                       marked_old[k] ->
                       n * k < marked_old.length ->
                       marked_old[k * n] };
    assert { prime_products_marked marked_old marked n marked.length };
    assert { (forall k. 2 <= k < marked.length ->
                       not marked_old[k] -> n * k < marked.length ->
                       marked[n * k])
              }

  let lemma conservation_only_products_marked (marked: seq bool) (n i j: int)
    requires { 2 <= i < n /\ 2 <= j < marked.length /\ i * j < marked.length }
    requires { only_products_marked marked n }
    ensures { only_products_marked marked[(i * j) <- true] n } =
    assert { forall k. 0 <= k < marked.length ->
                       k <> i * j ->
                       marked[(i * j) <- true][k] = marked[k] };
    assert { forall k.
               2 <= k < marked.length ->
               k <> i * j ->
               marked[(i * j) <- true][k] ->
               exists x y. 2 <= x < n /\ 2 <= y < marked.length /\ k = x * y };
    assert { marked[i * j] -> 2 <= i < n -> 2 <= j < marked.length ->
             exists x y. 2 <= x < n /\ 2 <= y < marked.length /\ x * y = i * j }

  let lemma conservation_previously_marked_products (marked: seq bool)
                                                    (nexts: seq int)
                                                    (n: int)
    requires { 2 <= n < marked.length /\ marked.length = nexts.length /\
               nexts[n] <= marked.length }
    requires { previously_marked_products marked n }
    requires { only_products_marked marked (n + 1) }
    requires { inv_marked_nexts marked nexts }
    requires { inv_marked_old_nexts2 marked nexts nexts[n] }
    requires { all_products_marked marked n marked.length }
    ensures { previously_marked_products marked nexts[n] } =
    assert { previously_marked_products marked (n + 1) };
    assert { forall i. n < i < nexts[n] -> marked[i] };
    assert { forall i. n < i < nexts[n] ->
              ((exists k l. 2 <= k <= n /\ 2 <= l < marked.length /\ k * l = i)
               by marked[i]) };
    marked_impl_all_products_marked marked (n + 1);
    assert { forall i j.
              n < i < nexts[n] ->
              2 <= j < marked.length ->
              i * j < marked.length ->
              (marked[i * j] by
              (exists k l. 2 <= k <= n /\ 2 <= l < marked.length /\
                           k * l = i)) };
    assert { forall i.
              n < i < nexts[n] ->
              all_products_marked marked i marked.length }

  lemma conservation_previously_marked_products_on_marked_change:
    forall marked n.
      previously_marked_products marked n ->
      forall i. 0 <= i < marked.length ->
                previously_marked_products marked[i <- true] n


(*******************************************************************************)
(*                                                                             *)
(*                      INVARIANTS SIMPLES DE FONCTIONS                        *)
(*                                                                             *)
(*******************************************************************************)

  let lemma conservation_inv_marked_old_nexts2 (marked: seq bool)
                                               (nexts: seq int)
                                               (max n p: int)
    requires { inv_marked_old_nexts2 marked nexts n /\
                 nexts[n] > n > 0 /\
                 div max nexts[n] <= div max n by
                 forall i. p < i < nexts[p] -> marked[i] /\
                 inv_marked_old_nexts2_partial marked nexts n p }
    ensures { inv_marked_old_nexts2 marked nexts nexts[n] } = ()

  let lemma unchanged_other_elements (s1: seq 'a) (s2: seq 'a) (i: int) (v: 'a)
    requires { 0 <= i < length s1 /\ length s1 = length s2 }
    requires { s1 = s2[i <- v] }
    ensures  { forall j. 0 <= j < length s1 -> i <> j -> s1[j] = s2[j] } = ()

  type t = private {
    mutable ghost nexts: seq int;
    mutable ghost marked: seq bool;
    max: int;
    (* mutable n: int *)
  }
    (* invariant { 2 <= n <= max /\ mod n 2 = 1 } *)
    invariant { max >= 3 }
    invariant { nexts.length = marked.length = max + 1 }
    invariant { inv_nexts nexts nexts.length }
    invariant { inv_marked_nexts marked nexts }
    invariant { forall i. 3 <= i <= max -> mod i 2 = 0 -> marked[i] }
    invariant { forall i. 3 <= i < max - 1 -> mod i 2 = 1 -> mod (Seq.get nexts i) 2 = 1 \/ Seq.get nexts i = max + 1 }
    invariant { Seq.get nexts max = max + 1 /\
                (mod (max - 1) 2 = 0 -> Seq.get nexts (max - 1) = max) /\
                (mod (max - 1) 2 = 1 -> Seq.get nexts (max - 1) = max + 1) }

    by { nexts = Seq.create 4 (fun i -> i + 1);
         marked = Seq.create 4 (fun i -> i < 2);
         max = 3; (* n = 3 *) }

  val create (max: int) : t
    requires { max >= 3 }
    ensures  { result.max = max }
    ensures  { Seq.get result.marked 0 = Seq.get result.marked 1 = true /\
               not Seq.get result.marked 2 }
    ensures  { forall i. 3 <= i <= max ->
                         mod i 2 = 0 <-> Seq.get result.marked i }
    ensures  { forall i. 3 <= i < max - 1 ->
                         mod i 2 = 0 -> Seq.get result.nexts i = i + 1 }
    ensures  { forall i. 3 <= i < max - 1 ->
                         mod i 2 = 1 -> Seq.get result.nexts i = i + 2 }
    ensures  { forall i. 0 <= i <= max -> Seq.get result.marked i -> i < 2 \/ divides 2 i }

  val set_next (t: t) (i v: int) : unit
    requires { 0 <= i <= t.max /\ i < v <= t.max + 1 }
    requires { mod i 2 = 1 }
    requires { forall j. i < j < v -> Seq.get t.marked j }
    requires { not Seq.get t.marked i }
    requires { mod v 2 = 1 \/ v = t.max + 1 }
    writes   { t.nexts }
    ensures  { t.nexts = (old t.nexts)[i <- v] }

  val get_next (t: t) (i: int) : int
    requires { 3 <= i <= t.max }
    requires { mod i 2 = 1 }
    ensures  { 3 <= result <= t.max + 1 }
    ensures  { result = t.nexts[i] }
    ensures  { mod result 2 = 1 \/ result = t.max + 1 }

  val set_mark (t: t) (i: int) : unit
    requires { 0 <= i <= t.max }
    requires { mod i 2 = 1 }
    writes   { t.marked }
    ensures  { t.marked = (old t.marked)[i <- true] }

  val get_mark (t: t) (i: int) : bool
    requires { 0 <= i <= t.max }
    requires { mod i 2 = 1 }
    ensures { result = t.marked[i] }

  val get_max (t: t) : int
    ensures { result = t.max /\ result >= 2 }

let remove_products (t: t) (n: int) : unit
  requires { 3 <= n <= t.max /\ n * n <= t.max }
  requires { inv_remove_products t.nexts t.marked n }
  requires { previously_marked_products t.marked n }
  requires { only_products_marked t.marked n }
  requires { inv_marked_old_nexts2 t.marked t.nexts n }
  ensures { inv_remove_products t.nexts t.marked n }
  ensures { inv_marked_old_nexts2 t.marked t.nexts t.nexts[n] }
  ensures { previously_marked_products t.marked t.nexts[n] }
  ensures { only_products_marked t.marked t.nexts[n] }
  = let ghost max = t.max in
    let ghost marked_old = t.marked in
    assert { inv_marked_old_nexts2 marked_old t.nexts n by
               inv_marked_old_nexts2 t.marked t.nexts n };
    assert { inv_marked_old_nexts2_partial t.marked t.nexts n n by
                 inv_marked_old_nexts2 t.marked t.nexts n /\ n <= div max n by
                 n * n <= max };
    assert { only_products_marked marked_old n /\
             only_products_marked t.marked (n + 1) by
               only_products_marked t.marked n };
    let rec loop (p: int) (ghost x: int) =
      requires { n <= p <= max /\ 3 <= n <= max /\ mod p 2 = 1 /\
                 p <= x < t.nexts[p] /\ t.nexts[x] = t.nexts[p] /\
                 t.marked[n * n] }
      requires { inv_remove_products t.nexts t.marked n }
      requires { previously_marked_products t.marked n }
      requires { not t.marked[p] }
      requires { inv_marked_marked_old t.marked marked_old }
      requires { inv_marked_old_nexts1 marked_old t.nexts x }
      requires { inv_marked_old_nexts2 marked_old t.nexts n }
      requires { prime_products_marked marked_old t.marked n t.nexts[x] }
      requires { inv_marked_old_nexts2_partial t.marked t.nexts n p }
      requires { only_products_marked t.marked (n + 1) }
      ensures { inv_remove_products t.nexts t.marked n }
      ensures { inv_marked_old_nexts2 t.marked t.nexts t.nexts[n] }
      ensures { inv_marked_marked_old t.marked marked_old }
      ensures { previously_marked_products t.marked n }
      ensures { prime_products_marked marked_old t.marked n t.marked.length }
      ensures { only_products_marked t.marked (n + 1) }
      variant { max - t.nexts[p] }
      let next = get_next t p in
      if 0 <= next < get_max t + 1 then
        if n * next <= get_max t then begin
          ghost (conservation_only_products_marked t.marked (n + 1) n
                                                   t.nexts[p]);
          let ghost marked_copy = t.marked in
          set_mark t (n * next);
          unchanged_other_elements t.marked marked_copy (n * next) true;
          assert { n * t.nexts[p] < n * (t.nexts[p] + 1) };
          assert { n > 0 -> next >= 2 -> n * next >= n * 2 };
          assert { not t.marked[p] by n * next > p /\ p <= length t.marked by
                     p < 2 * p < 2 * t.nexts[p] <= n * t.nexts[p] by
                     t.nexts[p] >= 2 /\ n > 0 };
          assert { not marked_old[p] };
          assert { not marked_old[t.nexts[p]] by
                      2 <= p < next <= div max n by
                      n * next <= max };
          assert { prime_products_marked marked_old t.marked n t.nexts[next] by
                     prime_products_marked marked_old t.marked n t.nexts[x] };
          assert { forall i. 0 <= i < p -> t.nexts[i] <= p by
                     not t.marked[p] /\
                     forall i. 0 <= i < p ->
                               forall j. i < j < t.nexts[i] -> t.marked[j] by
                     inv_marked_nexts t.marked t.nexts };
          assert { inv_marked_old_nexts2_partial t.marked t.nexts n p by
                     n * next > n * p >= 2 * p > p by
                     n >= 2 /\ t.nexts[p] > p /\ p >= 1 };
          if get_mark t next then begin
            assert { inv_marked_nexts t.marked t.nexts };
            assert { inv_marked_old_nexts1 marked_old t.nexts x };
            assert { 0 <= p < t.marked.length };
            assert { t.nexts[p] <> t.marked.length };
            assert { t.marked[t.nexts[p]] };
            assert { inv_marked_old_nexts1 marked_old t.nexts next by
                       x < next };
            let ghost nexts_copy = t.nexts in
            set_next t p (get_next t next);
            unchanged_other_elements t.nexts nexts_copy p nexts_copy[next];
            assert { inv_marked_old_nexts1 marked_old t.nexts next by
                       p <= x < next /\ forall j. next <= j < length t.nexts -> t.nexts[j] = nexts_copy[j] };
            assert { prime_products_marked marked_old t.marked n next by
                       p < next };
            assert { 0 <= p < t.marked.length };
            assert { t.marked[next] };
            assert { not marked_old[p] by not t.marked[p] };
            assert { not marked_old[next] };
            assert { 2 <= p < next <= div max n by n * next <= max };
            assert { prime_products_marked marked_old t.marked n next };
            assert { t.nexts[p] > next };
            assert { div (length marked_old - 1) n <= max };
            loop p next
          end else begin
            assert { forall i. p < i < t.nexts[p] -> t.marked[i] by
                       inv_marked_nexts t.marked t.nexts };
            assert { p < next };
            loop next next
          end
        end else begin
          assert { forall i. p <= i <= div t.max n -> t.nexts[i] <= div t.max n -> not t.marked[i] -> not t.marked[t.nexts[i]] by
                   (next > div max n /\ forall i. p < i < next -> t.marked[i]) by
                   n * next > n * div max n };
          ghost (conservation_inv_marked_old_nexts2 t.marked t.nexts max n p)
      end else ghost (conservation_inv_marked_old_nexts2 t.marked t.nexts max n p) in
      ghost (conservation_only_products_marked t.marked (n + 1)
                                               n n);
      assert { all_primes t.marked n };
      let ghost marked_copy = t.marked in
      set_mark t (n * n);
      unchanged_other_elements t.marked marked_copy (n * n) true;
      assert { forall i. 0 <= i < n -> t.nexts[i] <> n * n by
               forall i. 0 <= i < n -> t.nexts[i] <= n < n * n by
                 not t.marked[n] /\
                 forall i. 0 <= i < n ->
                           forall j. i < j < t.nexts[i] -> t.marked[j] by
                   inv_marked_nexts t.marked t.nexts };
      loop n n;
      ghost (prev_and_new_impl_all_products_marked marked_old t.marked n max);
      ghost (conservation_previously_marked_products t.marked t.nexts n)

let lemma previously_marked_products_impl_prime (marked: seq bool) (n: int)
  requires { 2 <= n < marked.length /\ not marked[n] }
  requires { previously_marked_products marked n }
  ensures { prime n } =
  assert { forall k.
             2 <= k < n -> not divides k n by
           forall k.
             2 <= k < n ->
             not (exists i. 2 <= i < marked.length /\ n = k * i) }

let lemma only_products_marked_impl_not_marked (marked: seq bool)
                                               (nexts: seq int)
                                               (n: int)
  requires { 2 <= n < marked.length }
  requires { only_products_marked marked nexts[n] }
  requires { prime n }
  ensures { not marked[n] } =
  assert { forall i j. 2 <= i < n -> 2 <= j < marked.length -> i * j <> n }

end

module EulerSieveImpl

  use int.Int
  use seq.Seq
  use array.Array
  use array.Init

  use int.Abs
  use int.EuclideanDivision
  use number.Divisibility
  use number.Prime

  use DivisibilityResults
  use EulerSieveSpec

  let lemma conservation_inv_arr_on_mark (arr: array int) (i: int)
    requires { forall j k. 0 <= j < length arr -> j < k < div (abs arr[j]) 2 -> arr[k] < 0 }
    requires { forall i. 0 <= i < length arr -> i < div (abs arr[i]) 2 <= length arr }
    requires { 0 <= i < length arr }
    requires { arr[i] >= 0 }
    ensures  { forall j k. 0 <= j < length arr -> j < k < div (abs arr[i <- - arr[i]][j]) 2 -> arr[i <- - arr[i]][k] < 0 } =
    assert { forall j. 0 <= j < length arr -> arr[j] < i -> arr[j] = arr[i <- - arr[i]][j] };
    assert { forall j. 0 <= j < length arr -> arr[i] < j -> arr[j] = arr[i <- - arr[i]][j] }

  let lemma conservation_inv_arr_on_jump (arr: array int) (min i: int)
    requires { min >= 0 }
    requires { forall j k. min <= j < length arr -> j < k < div (abs arr[j]) 2 -> arr[k] < 0 }
    requires { forall i. min <= i < length arr -> i < div (abs arr[i]) 2 <= length arr }
    requires { min <= i < length arr }
    requires { 0 <= div arr[i] 2 < length arr }
    requires { arr[div arr[i] 2] < 0 }
    (* requires { forall k. i < k < - arr[div arr[i] 2] -> arr[i <- - arr[div arr[i] 2]][k] < 0 } *)
    ensures  { forall j k. min <= j < length arr -> j < k < div (abs arr[i <- - arr[div arr[i] 2]][j]) 2 -> arr[i <- - arr[div arr[i] 2]][k] < 0 } =
    let ghost next = div arr[i] 2 in
    let ghost arr1 = arr[i <- - arr[next]] in
    assert { forall j. min <= j < i -> arr[j] = arr1[j] };
    assert { forall j. i < j < length arr -> arr[j] = arr1[j] }
    (* assert { forall j k. 0 <= j < length arr -> arr[j] < i -> j < k < arr1[j] -> arr1[k] < 0 } *)

  type t = {
    mutable ghost nexts: seq int;
    mutable ghost marked: seq bool;
    arr: array int;
    max: int;
    max_arr: int
  }
    (* invariant { 2 <= n <= max } *)
    invariant { max >= 3 }
    invariant { Seq.length nexts = Seq.length marked = max + 1 }
    invariant { div (max - 1) 2 = max_arr }
    invariant { Array.length arr = max_arr + 1 }
    invariant { inv_nexts nexts (Seq.length nexts) }
    invariant { inv_marked_nexts marked nexts }
    invariant { forall i. 3 <= i <= max -> mod i 2 = 0 -> Seq.get marked i }
    invariant { forall i. 3 <= i < max - 1 -> mod i 2 = 1 -> mod (Seq.get nexts i) 2 = 1 \/ Seq.get nexts i = max + 1 }
    invariant { Seq.get nexts max = max + 1 /\
                (mod (max - 1) 2 = 0 -> Seq.get nexts (max - 1) = max) /\
                (mod (max - 1) 2 = 1 -> Seq.get nexts (max - 1) = max + 1) }
    (* glueing invariant *)
    invariant { forall i. 0 <= i <= max_arr -> -(max + 1) <= arr[i] <= max + 1 }
    invariant { forall i. 0 <= i <= max_arr ->
                          Seq.get marked (2 * i + 1) <-> arr[i] < 0 }
    invariant { forall i. 0 <= i <= max_arr ->
                          not Seq.get marked (2 * i + 1) ->
                          arr[i] = Seq.get nexts (2 * i + 1) }
    invariant { forall i. 0 <= i <= max_arr ->
                          Seq.get marked (2 * i + 1) ->
                          arr[i] = - Seq.get nexts (2 * i + 1) }
    invariant { forall i. 0 <= i <= max_arr -> i < div (abs arr[i]) 2 <= max_arr + 1 /\ abs arr[i] <= max + 1 }
    invariant { forall i j. 0 <= i <= max_arr -> i < j < div (abs arr[i]) 2 -> arr[j] < 0 }
    by { nexts = Seq.create 4 (fun i -> i + 1);
         marked = Seq.create 4 (fun i -> i < 2);
         arr = (Array.make 2 0)[0 <- -2][1 <- 4];
         max = 3; max_arr = 1 }

  let create (max: int) : t
    requires { max >= 3 }
    ensures  { result.max = max }
    ensures  { Seq.get result.marked 0 = Seq.get result.marked 1 = true /\
               not Seq.get result.marked 2 }
    ensures  { forall i. 1 <= i <= div (max - 1) 2 ->
                         not Seq.get result.marked (2 * i + 1) }
    ensures  { forall i. 2 <= i <= div (max + 1) 2 ->
                         2 * i <= max ->
                         Seq.get result.marked (2 * i) }
    ensures  { forall i. 1 <= i <= div (max - 1) 2 ->
                         2 * i + 1 < max - 1 ->
                         Seq.get result.nexts (2 * i + 1) = 2 * i + 3 }
    ensures  { forall i. 2 <= i <= div (max - 1) 2 ->
                         2 * i < max - 1 ->
                         Seq.get result.nexts (2 * i) = 2 * i + 1 }
    ensures  { forall i. 0 <= i <= max -> Seq.get result.marked i -> i < 2 \/ divides 2 i }
  = let len = max + 1 in
    let len_arr = div (max - 1) 2 + 1 in
    let ghost nexts = Seq.create len (fun i ->
          if i = max then max + 1
          else if i = max - 1 then if mod i 2 = 0 then max else max + 1
          else if i < 3 || mod i 2 = 0 then i + 1
          else i + 2) in
    let ghost marked = Seq.create len (fun i -> i = 0 || i = 1 || (i > 2 && mod i 2 = 0)) in
    { nexts = nexts;
      marked = marked;
      arr = Init.init len_arr (fun i ->
          if i = len_arr - 1 then max + 1
          else if i = 0 then -2
          else 2 * i + 3);
      (* n = 3; *)
      max = max;
      max_arr = div (max - 1) 2 }

  let set_next (t: t) (i v: int) : unit
    requires { 0 <= i <= t.max /\ i < v <= t.max + 1 }
    requires { mod i 2 = 1 }
    requires { forall j. i < j < v -> Seq.get t.marked j }
    requires { not Seq.get t.marked i }
    requires { mod v 2 = 1 \/ v = t.max + 1 }
    writes   { t.nexts, t.arr }
    ensures  { t.nexts = Seq.set (old t.nexts) i v }
  = ghost ( conservation_inv_marked_nexts_on_nexts_change t.marked t.nexts i v );
    t.arr[div i 2] <- v;
    ghost (t.nexts <- Seq.set t.nexts i v)

  let get_next (t: t) (i: int) : int
    requires { 3 <= i <= t.max }
    requires { mod i 2 = 1 }
    ensures  { 3 <= result <= t.max + 1 }
    ensures  { result = Seq.get t.nexts i }
    ensures  { mod result 2 = 1 \/ result = t.max + 1 }
  = let x = div i 2 in
    if t.arr[x] < 0 then - t.arr[x] else t.arr[x]

  let set_mark (t: t) (i: int) : unit
    requires { 0 <= i <= t.max }
    requires { mod i 2 = 1 }
    writes   { t.marked, t.arr }
    ensures  { t.marked = Seq.set (old t.marked) i true }
  = let x = div i 2 in
    ghost ( conservation_inv_marked_nexts_on_marked_change t.marked t.nexts i);
    if t.arr[x] >= 0 then begin
      ghost ( conservation_inv_arr_on_mark t.arr x );
      t.arr[x] <- - t.arr[x]
    end;
    ghost (t.marked <- Seq.set t.marked i true)

  let get_mark (t: t) (i: int) : bool
    requires { 0 <= i <= t.max }
    requires { mod i 2 = 1 }
    ensures  { result = Seq.get t.marked i }
  = t.arr[div i 2] < 0

  let get_max (t: t) : int
    ensures { result = t.max /\ result >= 2 }
  = t.max

  clone EulerSieve with type t = t,
    val create = create,
    val set_next = set_next, val get_next = get_next,
    val set_mark = set_mark, val get_mark = get_mark,
    val get_max = get_max

  predicate inv_count (arr: array int) (min: int) =
    forall i. min <= i < arr.length ->
              (i < div (abs arr[i]) 2 <= arr.length /\
               (forall j. i < j < div (abs arr[i]) 2 -> arr[j] < 0) /\
               (forall j. 2 * i + 1 < j < abs arr[i] -> not prime j) (*/\
               (forall j. min <= j < arr.length -> arr[j] >= 0 <-> prime (2 * j + 1))*) )

  let euler_sieve (max: int) : array int
    requires { max >= 3 }
    ensures { all_differents result result.length }
    ensures { forall i. 0 <= i < result.length -> prime result[i] }
    ensures { forall i. 2 <= i <= max -> prime i ->
                        exists j. 0 <= j < result.length /\ result[j] = i }
  = let t = create max in
    let rec loop (n: int) =
      requires { 3 <= n <= max }
      requires { n * n <= max }
      requires { previously_marked_products t.marked n }
      requires { only_products_marked t.marked n }
      requires { inv_marked_old_nexts2 t.marked t.nexts n }
      requires { inv_remove_products t.nexts t.marked n }
      ensures { forall i. 0 <= i < Seq.length t.marked ->
                          not Seq.get t.marked i <-> prime i }
      variant { max + 1 - n }
        remove_products t n;
        let nn = get_next t n in
        if nn * nn <= max then begin
          assert { all_primes t.marked n /\ not Seq.get t.marked n /\
                   nn <= div max (nn) };
          ghost (previously_marked_products_impl_prime t.marked
                                                       (nn));
          assert { (forall i. n < i < nn -> not prime i) by
                   (forall i.
                      n < i < nn ->
                      (exists j k.
                         2 <= j < nn /\
                         2 <= k < Seq.length t.marked /\
                         j * k = i) by
                           Seq.get t.marked i /\
                           only_products_marked t.marked (nn)) by
                   (forall i. n < i < nn -> Seq.get t.marked i) /\
                   only_products_marked t.marked (nn) };
          loop (nn)
        end else begin
          ghost (not_prime_impl_divisor_under_sqrt (nn));
          assert { forall i.
                     2 <= i < Seq.length t.marked ->
                     not Seq.get t.marked i ->
                     not (exists k l. 2 <= k < nn /\ 2 <= l < i /\
                                      k * l = i) by
                   previously_marked_products t.marked (nn) };
          ghost (no_prod_impl_no_divider (nn));
          assert { forall i. 2 <= i < Seq.length t.marked ->
                             not Seq.get t.marked i ->
                             prime i by
                   forall i.
                    2 <= i < Seq.length t.marked ->
                    not Seq.get t.marked i ->
                    (not (exists k. 2 <= k < nn /\ k <> i /\
                                    divides k i) by
                    i < nn * nn /\ forall k. 2 <= k -> k <> i -> (divides k i <-> exists l. 2 <= l < i /\ k * l = i) by divides k i -> 2 <= div i k < i) }
        end in
    if max >= 9 then loop 3;
    assert { forall i. 1 <= i <= t.max_arr -> t.arr[i] >= 0 <-> prime (2 * i + 1) };
    assert { forall p i. 1 <= p <= t.max_arr -> 2 * p + 1 < i < abs t.arr[p] -> not prime i by
             mod i 2 = 0 -> (Seq.get t.marked i by Seq.get t.nexts (2 * i + 1) = t.arr[i]) };
    assert { forall i. 1 <= i <= t.max_arr -> t.arr[i] >= 0 <-> prime (2 * i + 1) };
    assert { forall j. 1 <= j <= t.max_arr -> t.arr[0 <- 2][j] = t.arr[j] };
    let ref cnt = 1 in
    let ref p = 1 in
    t.arr[0] <- 2;
    while (* t.arr[p] *) 2 * p + 1 <= max (* || p <= t.max_arr *) do
      invariant { 1 <= p <= t.max_arr + 1 }
      invariant { 1 <= cnt <= p }
      invariant { 2 * p + 1 <= max -> t.arr[p] >= 0 }
      invariant { 2 * p + 1 <= max -> prime (2 * p + 1) }
      invariant { inv_count t.arr cnt }
      invariant { all_differents t.arr cnt }
      invariant { all_inf_or_eq t.arr cnt (2 * p) }
      invariant { forall i. cnt <= i <= t.max_arr -> t.arr[i] >= 0 <-> prime (2 * i + 1) }
      invariant { forall i. 0 <= i < cnt -> prime t.arr[i] }
      invariant { forall i. 2 <= i < 2 * p + 1 (* t.arr[p] *) -> prime i ->
                            exists j. 0 <= j < cnt /\ t.arr[j] = i }
      variant { t.max_arr + 1 - p , max + 1 - t.arr[p] }
      let next = div t.arr[p] 2 in
      if next <= t.max_arr then begin
         assert { 1 <= p <= t.max_arr /\ t.arr[p] >= 0 /\ prime (2 * p + 1) };
         if t.arr[next] < 0 then begin
           label BeforeAssign in
           t.arr[p] <- - t.arr[next];
           assert { forall i. 0 <= i < cnt ->
                              t.arr[i] = (t.arr at BeforeAssign)[i] };
           assert { forall k. 0 <= k < length t.arr -> k <> p -> t.arr[k] = (t.arr at BeforeAssign)[k] };
           assert { (forall i. 0 <= i <= length t.arr -> i <> p ->
                               t.arr[i] = (t.arr at BeforeAssign)[i]) /\
                     forall i. p < i < div t.arr[p] 2 -> t.arr[i] < 0 by
                     ((forall j. p < j < div (t.arr at BeforeAssign)[p] 2 -> (t.arr at BeforeAssign)[j] < 0) /\
                      (forall j. next < j < div (abs (t.arr at BeforeAssign)[next]) 2 -> (t.arr at BeforeAssign)[j] < 0 by cnt < next < length t.arr) /\
                      div t.arr[p] 2 = div (abs (t.arr at BeforeAssign)[next]) 2) };
           assert { t.arr[p] = abs (t.arr at BeforeAssign)[next] > (t.arr at BeforeAssign)[p] > p };
           conservation_inv_arr_on_jump pure { t.arr at BeforeAssign } cnt p;
           assert { cnt <= next < length t.arr };
           assert { (forall j. 2 * p + 1 < j < (t.arr at BeforeAssign)[p] -> not prime j) /\
                    (forall j. 2 * next + 1 < j < abs (t.arr at BeforeAssign)[next] -> not prime j (*by 1 <= next <= t.max_arr*)) }
         end else begin
           label BeforeAssign in
           t.arr[cnt] <- 2 * p + 1 (* 2 * next + 1 *);
           assert { forall i. 0 <= i < length t.arr -> i <> cnt ->
                              t.arr[i] = (t.arr at BeforeAssign)[i] };
           (* assert { forall i. (cnt + 1 <= i <= t.max_arr) -> *)
           (*                    t.arr[i] = (t.arr at BeforeAssign)[i] }; *)
           assert { forall i. 0 <= i < cnt -> prime t.arr[i] };
           assert { prime t.arr[cnt] };
           cnt <- cnt + 1;
           assert { exists i. 0 <= i <= cnt /\ t.arr[i] = 2 * p + 1 };
           p <- next;
           assert { forall j. 2 * p + 1 < j < (t.arr at BeforeAssign)[p] -> not prime j by (cnt at BeforeAssign) <= p < length t.arr };
           assert { (p at BeforeAssign) < div (abs (t.arr at BeforeAssign)[p at BeforeAssign]) 2 <= length t.arr};
           assert { next < div (abs (t.arr at BeforeAssign)[next]) 2 by cnt <= next < length t.arr (* by (p at BeforeAssign) < div (abs (t.arr at BeforeAssign)[p at BeforeAssign]) 2 <= length t.arr *) };
           assert { forall i. 2 * (p at BeforeAssign) + 1 < i < (t.arr at BeforeAssign)[p at BeforeAssign] -> not prime i };
                    (* forall j. 2 * p + 1 < j < (t.arr at BeforeAssign)[p] -> not prime j } *)
           assert { forall k. cnt <= k < length (t.arr at BeforeAssign) -> t.arr[k] = (t.arr at BeforeAssign)[k] }
         end
      end else begin
        label BeforeAssign in
        t.arr[cnt] <- 2 * p + 1;
        assert { forall i. 0 <= i < length t.arr -> i <> cnt ->
                           t.arr[i] = (t.arr at BeforeAssign)[i] };
        (* assert { forall i. (cnt + 1 <= i <= t.max_arr) -> *)
        (*                    t.arr[i] = (t.arr at BeforeAssign)[i] }; *)
        assert { forall i. 0 <= i < cnt -> prime t.arr[i] };
        assert { prime t.arr[cnt] };
        cnt <- cnt + 1;
        assert { exists i. 0 <= i <= cnt /\ t.arr[i] = 2 * p + 1 };
        p <- t.max_arr + 1;
        (* assert { forall j. 2 * p + 1 < j < (t.arr at BeforeAssign)[p] -> not prime j by (cnt at BeforeAssign) <= p < length t.arr }; *)
        (* assert { (p at BeforeAssign) < div (abs (t.arr at BeforeAssign)[p at BeforeAssign]) 2 <= length t.arr}; *)
        (* assert { next < div (abs (t.arr at BeforeAssign)[next]) 2 by cnt <= next < length t.arr (\* by (p at BeforeAssign) < div (abs (t.arr at BeforeAssign)[p at BeforeAssign]) 2 <= length t.arr *\) }; *)
        assert { forall i. 2 * (p at BeforeAssign) + 1 < i < (t.arr at BeforeAssign)[p at BeforeAssign] -> not prime i };
                 (* forall j. 2 * p + 1 < j < (t.arr at BeforeAssign)[p] -> not prime j } *)
        assert { forall k. cnt <= k < length (t.arr at BeforeAssign) -> t.arr[k] = (t.arr at BeforeAssign)[k] }
      end
    done;
    (* t.arr[cnt] <- 2 * p + 1; *)
    (* cnt <- cnt + 1; *)
    sub t.arr 0 cnt

end
