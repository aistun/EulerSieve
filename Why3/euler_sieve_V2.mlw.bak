module EulerSieve

use int.Int
use number.Divisibility
use number.Prime
use array.Array
use int.EuclideanDivision

function min (a b: int) : int = if a <= b then a else b

lemma min_inf:
  forall a b. min a b <= a /\ min a b <= b
  
lemma min_ref:
  forall a. min a a = a

lemma min_sym:
  forall a b. min a b = min b a

lemma comp_mult_2:
  forall n k. n > 0 -> k >= 2 -> n * k >= n * 2

lemma div_croissance_locale:
  forall i n. 0 <= i -> n > 0 -> div i n <= div (i + 1) n
  
let rec lemma div_croissance (i j n: int)
  requires { 0 <= i <= j /\ n > 0 }
  ensures { div i n <= div j n }
  variant { j - i }
  = if i < j then
      div_croissance i (j - 1) n
  
lemma div_mult_1:
  forall n k max. n > 0 ->
                  max >= n ->
                  n * k <= max ->
                  k = div (n * k) n <= div max n

predicate inv_nexts (nexts: array int) (n: int) =
  forall i. 0 <= i < n ->
            i < nexts[i] <= n

predicate all_primes (marked: array bool) (n: int) =
  forall i. 0 <= i < n -> not marked[i] <-> prime i



predicate all_products_marked (marked: array bool) (i: int) =
  2 <= i < marked.length /\
  forall k. 2 <= k < marked.length ->
            i * k < marked.length ->
            marked[i * k]

predicate previously_marked_products (marked: array bool) (n: int) =
  forall i. 2 <= i < n ->
            all_products_marked marked i


predicate prime_products_marked (marked_old: array bool)
                                (marked: array bool)
                                (n max: int) =
  marked_old.length = marked.length /\
  n < max <= marked.length /\
  forall i. n <= i < max ->
            not marked_old[i] ->
            n * i < marked_old.length ->
            marked[n * i]

predicate prime_products_not_marked (marked_old: array bool)
                                    (marked: array bool) (n min: int) =
  2 <= min <= marked.length /\
  n >= 2 /\
  forall i. min <= i < marked.length ->
            not marked_old[i] ->
            n * i < marked.length ->
            not marked[n * i]

lemma conservation_products_not_marked_on_product_marked_change:
  forall marked marked_old n min.
    0 <= min < marked.length ->
    prime_products_not_marked marked_old marked n min ->
    n * min < n * (min + 1) ->
    prime_products_not_marked marked_old marked[(n * min) <- true] n (min + 1)

lemma conservation_previously_marked_products_on_marked_change:
  forall marked n.
    previously_marked_products marked n ->
    forall i. 0 <= i < marked.length ->
              previously_marked_products marked[i <- true] n



(*
  Relation invariante entre marked et nexts
  -----------------------------------------
  Une belle propriété localement vraie !
*)
predicate inv_marked_nexts (marked: array bool)
                           (nexts: array int) =
  marked.length = nexts.length /\
  forall i. 0 <= i < marked.length ->
            (* i + 1 < nexts[i] -> *)
            forall j. i < j < nexts[i] ->
                      marked[j]

predicate inv_marked_old_nexts1 (marked_old: array bool)
                                (nexts: array int)
                                (min: int) =
  marked_old.length = nexts.length /\
  forall i. min <= i < marked_old.length ->
            (* i + 1 < nexts[i] -> *)
            forall j. i < j < nexts[i] ->
                      marked_old[j]

predicate inv_marked_old_nexts2 (marked_old: array bool)
                                (nexts: array int)
                                (n: int) =
  marked_old.length = nexts.length /\
  marked_old.length >= 2 /\
  n >= 2 /\
  forall i. 2 <= i <= div (marked_old.length - 1) n ->
            nexts[i] <> marked_old.length ->
            not marked_old[i] ->
            not marked_old[nexts[i]]

predicate inv_marked_marked_old (marked: array bool)
                                (marked_old: array bool) =
  marked.length = marked_old.length /\
  forall i. 0 <= i < marked.length ->
            not marked[i] ->
            not marked_old[i]

predicate inv_marked_old_nexts2_partial (marked_old: array bool)
                                        (nexts: array int)
                                        (n: int)
                                        (p: int) =
  marked_old.length = nexts.length /\
  marked_old.length >= 2 /\
  n >= 2 /\
  p <= div (marked_old.length - 1) n /\
  forall i. 2 <= i < p ->
            nexts[i] <> marked_old.length ->
            not marked_old[i] ->
            not marked_old[nexts[i]]

lemma conservation_inv_marked_nexts_on_marked_change:
  forall marked nexts. marked.length = nexts.length ->
                       inv_marked_nexts marked nexts ->
                       forall i. 0 <= i < marked.length ->
                                  inv_marked_nexts marked[i <- true] nexts

(* lemma transition_inv_marked_nexts: *)
(*   forall marked nexts. marked.length = nexts.length -> *)
(*                        inv_nexts nexts nexts.length -> *)


lemma conservation_inv_marked_nexts_on_nexts_change:
  forall marked nexts.
    marked.length = nexts.length ->
    inv_marked_nexts marked nexts ->
    inv_nexts nexts marked.length ->
    not marked[2] ->
    forall i. 0 <= i < marked.length ->
              nexts[i] <> marked.length ->
              marked[nexts[i]] ->
              inv_marked_nexts marked nexts[i <- nexts[nexts[i]]]
              (* ((forall j. i < j < nexts[i] -> marked[j]) /\ *)
              (*  marked[nexts[i]] /\ *)
              (*  (forall j. nexts[i] < j < nexts[nexts[j]] -> marked[j])) *)

lemma conservation_inv_marked_old_nexts_on_marked_old_change:
  forall marked_old nexts n.
    marked_old.length = nexts.length ->
    marked_old.length >= 2 ->
    n >= 2 ->
    inv_marked_old_nexts2 marked_old nexts n ->
    forall i. 2 <= i <= div (marked_old.length - 1) n ->
              nexts[i] <> marked_old.length ->
              2 <= nexts[i] <= div (marked_old.length - 1) n ->
              nexts[nexts[i]] <> marked_old.length ->
              not marked_old[i] ->
              (not marked_old[nexts[nexts[i]]] by not marked_old[nexts[i]])

(*
  Note intéressante :
  -------------------
  Je pense que ...
  La seule implication à démontrer est que tous les nombres non marqués
  sont premiers !
  Car à chaque fois qu'on marque un nombre, par définition, c'est qu'il est
  produit de deux entiers (nécessairement compris entre 2 et inférieurs au
  nombre marqué). ET DONC, ça nous donne directement l'implication
  marked[i] -> not prime i, ce qui nous donne donc prime i -> not marked[i] !
  Et donc tous les nombres premiers inférieures ou égaux à n seront
  nécessairement marqués !
  Il y a quand même une petite subtilité, il faut montrer qu'aucun des éléments
  sautés dans la liste chainée des éléments n'est pas marquée. Ce qui est
  facilement surmontable car à chaque fois on vérifie si le suivant est marqué
  pour pouvoir sauter par dessus.
*)

predicate inv_remove_products (nexts: array int)
                              (marked: array bool)
                              (n: int) =
  nexts.length = marked.length /\
  not marked[2] /\
  all_primes marked n /\
  prime n /\
  not marked[n] /\
  inv_nexts nexts nexts.length

predicate inv_count (nexts: array int) (marked: array bool) (min: int) =
  nexts.length = marked.length /\
  forall i. min <= i < nexts.length ->
            i < nexts[i] <= nexts.length


predicate same_elements (a1: array 'a) (a2: array 'a) (n: int) =
  forall k. 0 <= k < n -> a1[k] = a2[k]

predicate all_differents (a: array 'a) (n: int) =
  forall i j. 0 <= i < j < n -> a[i] <> a[j]

predicate all_inf_or_eq (a: array int) (n k: int) =
  forall i. 0 <= i < n -> a[i] <= k

let remove_products (nexts: array int) (marked: array bool)
                    (max: int) (n: int) : unit
  requires { 2 <= n <= max }
  requires { nexts.length = marked.length = max + 1 }
  requires { inv_remove_products nexts marked n }
  requires { prime_products_not_marked marked marked n n }
  requires { previously_marked_products marked n }
  requires { inv_marked_nexts marked nexts }
  requires { inv_marked_old_nexts2 marked nexts n }
  ensures { inv_remove_products nexts marked n }
  ensures { inv_marked_nexts marked nexts }
  = let ghost marked_old = copy marked in
    assert { inv_marked_old_nexts1 marked_old nexts 0 }; 
    assert { inv_marked_old_nexts2 marked_old nexts n };
    let rec loop p (ghost x) =
      requires { 1 <= p <= max /\ 2 <= n <= max /\ p <= x < nexts[p] /\ nexts[x] = nexts[p] }
      requires { inv_remove_products nexts marked n }
      requires { prime_products_not_marked marked_old marked n nexts[p] }
      requires { previously_marked_products marked n }
      requires { not marked[p] }
      requires { inv_marked_nexts marked nexts }
      requires { inv_marked_marked_old marked marked_old }  
      requires { inv_marked_old_nexts1 marked_old nexts x }
      requires { inv_marked_old_nexts2 marked_old nexts n }  
      requires { prime_products_marked marked_old marked n nexts[x] }
      (* requires { inv_marked_old_nexts2_partial marked nexts n p } *)
      ensures { inv_remove_products nexts marked n }
      ensures { inv_marked_nexts marked nexts } 
      (* ensures { inv_marked_old_nexts2 marked nexts n } *)
      (* ensures { all_products_marked marked n } *)
      variant { max - nexts[p] }
      let next = nexts[p] in
      if 0 <= next < max + 1 then
        if n * next <= max then begin
          assert { prime_products_not_marked marked_old marked n nexts[p] };
          assert { prime_products_not_marked marked_old marked n
                                             (nexts[p] + 1) };
          assert { next >= 2 };
          marked[n * nexts[p]] <- true;
          assert { n * nexts[p] < n * (nexts[p] + 1) };
          assert { prime_products_not_marked marked_old marked n
                                             (nexts[p] + 1) };
          assert { next >= 2 };
          assert { n > 0 -> next >= 2 -> n * next >= n * 2 };
          assert { not marked[p] by n * nexts[p] > p };
          assert { not marked_old[p] };
          assert { not marked_old[nexts[p]] by
                      2 <= p < next <= div max n by
                      n * next <= max };
          assert { forall i. 2 <= i <= p - 1 < div max n ->
                               nexts[i] <> marked_old.length ->
                               not marked_old[i] ->
                               not marked_old[nexts[i]] };
          assert { prime_products_marked marked_old marked n nexts[next] };
          if marked[next] then begin
            assert { inv_marked_nexts marked nexts };
            assert { inv_marked_old_nexts1 marked_old nexts x };
            assert { 0 <= p < marked.length };
            assert { nexts[p] <> marked.length };
            assert { marked[nexts[p]] };
            assert { inv_marked_old_nexts1 marked_old nexts next by x < next };
            nexts[p] <- nexts[next];
            assert { inv_marked_old_nexts1 marked_old nexts next by p <= x < next };
            assert { prime_products_marked marked_old marked n next by p < next };
            assert { 0 <= p < marked.length };
            assert { marked[next] };
            (* assert { n < nexts[next] <= marked.length }; *)
            (* assert { n <= next < marked.length }; *)
            assert { not marked_old[p] by not marked[p] };
            assert { not marked_old[next] };
            assert { 2 <= p < next <= div max n by n * next <= max };
            assert { forall i. 2 <= i <= p - 1 < div max n ->
                               nexts[i] <> marked_old.length ->
                               not marked_old[i] ->
                               not marked_old[nexts[i]] };
            assert { prime_products_marked marked_old marked n next };
            (* assert { forall i. next < i < nexts[next] -> marked_old[i] by 
                       not marked_old[next] };
            assert { marked[n * next] };
            assert { prime_products_marked marked_old marked n nexts[next] }; *)
            loop p next
          end else
            loop next next
        end in
      if n * n <= max then begin
        assert { prime_products_not_marked marked_old marked n (n + 1) };
        marked[n * n] <- true;
        loop n n
      end

let euler_sieve (max: int) : array int
  requires { max >= 2 }
  ensures { all_differents result result.length }
= let nexts = make (max + 1) 0 in
  let marked = make (max + 1) false in
  for i = 0 to max do
    invariant { inv_nexts nexts i }
    nexts[i] <- i + 1;
    (* assert { forall j. 0 <= j < i + 1 -> j < nexts[j] <= i + 1 } *)
  done;
  let rec loop n =
    requires { 2 <= n <= max + 1 }
    requires { inv_remove_products nexts marked n }
    ensures { inv_remove_products nexts marked nexts.length }
    variant { max + 1 - n }
    if n <> max + 1 then begin
      remove_products nexts marked max n;
      loop nexts[n]
    end in
  loop 2;
  let rec count (p: int) (cnt: int) =
    requires { 2 <= p <= max }
    requires { 1 <= cnt <= p - 1 }
    requires { inv_count nexts marked cnt }
    requires { all_differents nexts cnt }
    requires { all_inf_or_eq nexts cnt p }
    ensures { 1 <= result <= max }
    ensures { all_differents nexts result }
    variant { max + 1 - nexts[p] }
    let next = nexts[p] in
    if next = max + 1 then begin nexts[cnt] <- 0; cnt end
    else
      if marked[next] then begin
        nexts[p] <- nexts[next];
        count p cnt
      end else begin
        (*
          Attention : des fois j'ai des bonnes idées ! ...
          On réécrit le début du tableau nexts !
          Parce que le nombre de nombres premiers <= n est strictement
          inférieur à n !
          Du coup on peut réécrire le tableau nexts en recopiant
          consécutivement les nombres premiers déja rencontrés et ceci ne
          modifiera pas les calculs de count par la suite
        *)
        nexts[cnt] <- next; (* une opération en plus ... *)
        (* assert { all_differents nexts cnt }; *)
        (* assert { cnt + 1 <= p < p + 1 /\ *)
        (*          all_inf_or_eq nexts cnt nexts[p] }; *)
        count next (cnt + 1)
      end in
  nexts[0] <- 2;
  sub nexts 0 (count 2 1)

end
