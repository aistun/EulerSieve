module ArithmeticResults

use int.Int
use number.Divisibility
use number.Prime
use int.EuclideanDivision

let lemma mult_croissance_locale (n a: int)
  requires { n > 0 /\ 0 <= a }
  ensures { n * a < n * (a + 1) } = ()

let rec lemma mult_croissance (n a b: int)
  requires { n > 0 /\ 0 <= a < b }
  ensures { n * a < n * b }
  variant { b - a }
  = if a + 1 = b then ()
    else mult_croissance n (a + 1) b

let lemma comp_mult_2 (n k: int)
  requires { n > 0 /\ k >= 2 }
  ensures { n * k >= n * 2 } = ()

let lemma div_croissance_locale1 (i n: int)
  requires { 0 <= i /\ n > 0 }
  ensures { div i n <= div (i + 1) n } = ()

let rec lemma div_croissance1 (i j n: int)
  requires { 0 <= i <= j /\ n > 0 }
  ensures { div i n <= div j n }
  variant { j - i }
  = if i < j then
      div_croissance1 i (j - 1) n

let rec lemma div_croissance_locale2 (m i: int)
  requires { i > 0 /\ m >= 0 }
  ensures { div m (i + 1) <= div m i }
  variant { m }
  = if m > 0 then div_croissance_locale2 (m - 1) i

let rec lemma div_croissance2 (m i j: int)
  requires { 0 < i <= j /\ m >= 0 }
  ensures { div m i >= div m j }
  variant { j - i }
  = if i < j then div_croissance2 m i (j - 1)

let lemma div_mult_1 (n k max: int)
  requires { n > 0 /\ max >= n /\ n * k <= max }
  ensures { k = div (n * k) n <= div max n } = ()

let lemma mult_borne_sous_exp (n a b: int)
  requires { a >= 1 /\ b >= 1 /\ n >= 1 /\ a * b < n }
  ensures { a < n /\ b < n } = ()

let lemma sq_ineq_local (a: int)
  requires { a >= 0 }
  ensures { a * a < (a + 1) * (a + 1) -> a < a + 1 } = ()

let rec lemma sq_ineq (a b: int)
  requires { a >= 0 /\ b >= 0 }
  requires { a * a < b * b }
  ensures { a < b }
  variant { b * b - a * a }
  = if (b - 1) * (b - 1) > a * a then
      sq_ineq a (b - 1)

end

module DivisibilityResults

use int.Int
use int.EuclideanDivision
use number.Divisibility
use number.Prime

let lemma divides_div (n m k: int)
  requires { 2 <= n /\ 2 <= m /\ 2 <= k < n /\ divides n m /\ not divides k m }
  ensures { not divides k (div m n) } = ()

let lemma divides_inf (n m: int)
  requires { 2 <= n /\ 2 <= m /\ divides n m /\
             forall k. 2 <= k < n -> not divides k m }
  ensures { forall k. 2 <= k < n -> not divides k (div m n) } = ()

let lemma not_prime_divider_limits (n: int)
  requires { not prime n /\ 2 <= n }
  ensures { exists i. 2 <= i /\ i * i <= n /\ divides i n } = ()

let lemma no_prod_impl_no_divider (n: int)
  requires { n >= 0 }
  ensures { forall i.
              2 <= i < n * n ->
              not (exists k l. 2 <= k < n /\ 2 <= l < i /\ k * l = i ) ->
              not (exists k. 2 <= k < n /\ k <> i /\ divides k i) } = ()

use ArithmeticResults

let lemma not_prime_impl_divisor_under_sqrt (n: int)
  requires { n >= 2 }
  ensures { forall i.
              2 <= i < n * n ->
              not prime i ->
              exists j. 2 <= j < i /\ ((j < n) by j * j < n * n /\ j >= 0) /\
                        divides j i } = ()

end

module EulerSieveSpec

use int.Int
use number.Divisibility
use number.Prime
use array.Array
use int.EuclideanDivision

use ArithmeticResults
use DivisibilityResults


(*******************************************************************************)
(*                                                                             *)
(*         INVARIANTS SUR LES RELATIONS ENTRE STRUCTURES DE DONNEES            *)
(*                                                                             *)
(*******************************************************************************)

predicate inv_nexts (nexts: array int) (n: int) =
  forall i. 0 <= i < n ->
            i < nexts[i] <= n

predicate inv_marked_nexts (marked: array bool)
                           (nexts: array int) =
  marked.length = nexts.length /\
  forall i. 0 <= i < marked.length ->
            forall j. i < j < nexts[i] ->
                      marked[j]

predicate inv_marked_old_nexts1 (marked_old: array bool)
                                (nexts: array int)
                                (min: int) =
  marked_old.length = nexts.length /\
  forall i. min <= i < marked_old.length ->
            forall j. i < j < nexts[i] ->
                      marked_old[j]

predicate inv_marked_old_nexts2 (marked_old: array bool)
                                (nexts: array int)
                                (n: int) =
  marked_old.length = nexts.length /\
  marked_old.length >= 2 /\
  n >= 2 /\
  forall i. 2 <= i <= div (marked_old.length - 1) n ->
            nexts[i] <= div (marked_old.length - 1) n ->
            not marked_old[i] ->
            not marked_old[nexts[i]]

predicate inv_marked_marked_old (marked: array bool)
                                (marked_old: array bool) =
  marked.length = marked_old.length /\
  forall i. 0 <= i < marked.length ->
            not marked[i] ->
            not marked_old[i]

predicate inv_marked_old_nexts2_partial (marked_old: array bool)
                                        (nexts: array int)
                                        (n: int)
                                        (p: int) =
  marked_old.length = nexts.length /\
  marked_old.length >= 2 /\
  n >= 2 /\
  p <= div (marked_old.length - 1) n /\
  forall i. 2 <= i < p ->
            nexts[i] <= div (marked_old.length - 1) n ->
            not marked_old[i] ->
            not marked_old[nexts[i]]


(*******************************************************************************)
(*                                                                             *)
(*                   PROPRIETES LIEES AUX NOMBRES PREMIERS                     *)
(*                                                                             *)
(*******************************************************************************)

predicate all_primes (marked: array bool) (n: int) =
  forall i. 0 <= i < n -> not marked[i] <-> prime i

predicate all_products_marked (marked: array bool) (i max: int) =
  2 <= i < marked.length /\
  forall k. 2 <= k < max ->
            i * k < marked.length ->
            marked[i * k]

predicate previously_marked_products (marked: array bool) (n: int) =
  forall i. 2 <= i < n ->
            all_products_marked marked i marked.length

predicate only_products_marked (marked: array bool) (n: int) =
  forall k. 2 <= k < marked.length ->
            marked[k] ->
            exists i j. 2 <= i < n /\ 2 <= j < marked.length /\ i * j = k

predicate prime_products_marked (marked_old: array bool)
                                (marked: array bool)
                                (n max: int) =
  marked_old.length = marked.length /\
  n < max <= marked.length /\
  forall i. n <= i < max ->
            not marked_old[i] ->
            n * i < marked_old.length ->
            marked[n * i]

end

module EulerSieve

use int.Int
use number.Divisibility
use number.Prime
use array.Array
use int.EuclideanDivision

use ArithmeticResults
use DivisibilityResults

use EulerSieveSpec

(*******************************************************************************)
(*                                                                             *)
(*                         QUELQUES PREDICATS UTILES                           *)
(*                                                                             *)
(*******************************************************************************)

predicate same_elements (a1: array 'a) (a2: array 'a) (n: int) =
  forall k. 0 <= k < n -> a1[k] = a2[k]

predicate all_differents (a: array 'a) (n: int) =
  forall i j. 0 <= i < j < n -> a[i] <> a[j]

predicate all_inf_or_eq (a: array int) (n k: int) =
  forall i. 0 <= i < n -> a[i] <= k


(*******************************************************************************)
(*                                                                             *)
(*         INVARIANTS SUR LES RELATIONS ENTRE STRUCTURES DE DONNEES            *)
(*                                                                             *)
(*******************************************************************************)

lemma conservation_inv_marked_nexts_on_marked_change:
  forall marked nexts. marked.length = nexts.length ->
                       inv_marked_nexts marked nexts ->
                       forall i. 0 <= i < marked.length ->
                                  inv_marked_nexts marked[i <- true] nexts

lemma conservation_inv_marked_nexts_on_nexts_change:
  forall marked nexts.
    marked.length = nexts.length ->
    inv_marked_nexts marked nexts ->
    inv_nexts nexts marked.length ->
    not marked[2] ->
    forall i. 0 <= i < marked.length ->
              nexts[i] <> marked.length ->
              marked[nexts[i]] ->
              inv_marked_nexts marked nexts[i <- nexts[nexts[i]]]


(*******************************************************************************)
(*                                                                             *)
(*                   PROPRIETES LIEES AUX NOMBRES PREMIERS                     *)
(*                                                                             *)
(*******************************************************************************)

let lemma marked_impl_all_products_marked (marked: array bool) (n: int)
  requires { 2 <= n <= marked.length }
  requires { previously_marked_products marked n }
  ensures { forall k i.
              2 <= k < n ->
              2 <= i < marked.length ->
              k * i < marked.length ->
              forall j.
                1 <= j < marked.length ->
                k * i * j < marked.length ->
                (marked[k * i * j] by
                   1 <= i * j < marked.length by
                   k >= 2 /\ i >= 2 /\ j >= 1 /\ k * (i * j) < marked.length) }
  = ()

let lemma prev_and_new_impl_all_products_marked (marked_old marked: array bool)
                                                (n max: int)
  requires { 2 <= n < marked.length /\ 2 <= max < marked.length /\
             marked_old.length = marked.length }
  requires { inv_marked_marked_old marked marked_old }
  requires { previously_marked_products marked_old n }
  requires { previously_marked_products marked n }
  requires { only_products_marked marked_old n }
  requires { prime_products_marked marked_old marked n marked.length }
  ensures { all_products_marked marked n marked.length } =
  assert { forall k. 2 <= k < marked_old.length ->
                     marked_old[k] ->
                     n * k < marked_old.length ->
                     exists i j. 2 <= i < n /\ 2 <= j < marked_old.length /\
                                 i * j = k /\ marked_old[i * j] };
  marked_impl_all_products_marked marked_old n;
  marked_impl_all_products_marked marked n;
  assert { forall k. 2 <= k < marked_old.length ->
                     marked_old[k] ->
                     n * k < marked_old.length ->
                     marked[k * n] by
           forall k. 2 <= k < marked_old.length ->
                     marked_old[k] ->
                     n * k < marked_old.length ->
                     marked_old[k * n] };
  assert { prime_products_marked marked_old marked n marked.length };
  assert { forall a b. ((a -> b) /\ (not a -> b)) -> b }

let lemma conservation_only_products_marked (marked: array bool) (n i j: int)
  requires { 2 <= i < n /\ 2 <= j < marked.length /\ i * j < marked.length }
  requires { only_products_marked marked n }
  ensures { only_products_marked marked[(i * j) <- true] n } =
  assert { forall k. 0 <= k < marked.length ->
                     k <> i * j ->
                     marked[(i * j) <- true][k] = marked[k] };
  assert { forall k.
             2 <= k < marked.length ->
             k <> i * j ->
             marked[(i * j) <- true][k] ->
             exists x y. 2 <= x < n /\ 2 <= y < marked.length /\ k = x * y };
  assert { marked[i * j] -> 2 <= i < n -> 2 <= j < marked.length ->
             exists x y. 2 <= x < n /\ 2 <= y < marked.length /\ x * y = i * j }

let lemma conservation_previously_marked_products (marked: array bool)
                                                  (nexts: array int)
                                                  (n: int)
  requires { 2 <= n < marked.length /\ marked.length = nexts.length /\
             nexts[n] <= marked.length }
  requires { previously_marked_products marked n }
  requires { only_products_marked marked (n + 1) }
  requires { inv_marked_nexts marked nexts }
  requires { inv_marked_old_nexts2 marked nexts nexts[n] }
  requires { all_products_marked marked n marked.length }
  ensures { previously_marked_products marked nexts[n] } =
  assert { previously_marked_products marked (n + 1) };
  assert { forall i. n < i < nexts[n] -> marked[i] };
  assert { forall i. n < i < nexts[n] ->
            ((exists k l. 2 <= k <= n /\ 2 <= l < marked.length /\ k * l = i) by
             marked[i]) };
  marked_impl_all_products_marked marked (n + 1);
  assert { forall i j.
            n < i < nexts[n] ->
            2 <= j < marked.length ->
            i * j < marked.length ->
            (marked[i * j] by
            (exists k l. 2 <= k <= n /\ 2 <= l < marked.length /\ k * l = i)) };
  assert { forall i.
            n < i < nexts[n] ->
            all_products_marked marked i marked.length }

lemma conservation_previously_marked_products_on_marked_change:
  forall marked n.
    previously_marked_products marked n ->
    forall i. 0 <= i < marked.length ->
              previously_marked_products marked[i <- true] n


(*******************************************************************************)
(*                                                                             *)
(*                    INVARIANTS DE SIMPLES DE FONCTIONS                       *)
(*                                                                             *)
(*******************************************************************************)

predicate inv_remove_products (nexts: array int)
                              (marked: array bool)
                              (n: int) =
  nexts.length = marked.length /\
  not marked[2] /\
  all_primes marked n /\
  prime n /\
  not marked[n] /\
  inv_nexts nexts nexts.length

predicate inv_count (nexts: array int) (marked: array bool) (min: int) =
  nexts.length = marked.length /\
  forall i. min <= i < nexts.length ->
            (i < nexts[i] <= nexts.length /\
             forall j. i < j < nexts[i] -> marked[j])

let lemma conservation_inv_marked_old_nexts2 (marked: array bool)
                                             (nexts: array int)
                                             (max n p: int)
  requires { inv_marked_old_nexts2 marked nexts n /\
               nexts[n] > n > 0 /\
               div max nexts[n] <= div max n by
               forall i. p < i < nexts[p] -> marked[i] /\
               inv_marked_old_nexts2_partial marked nexts n p }
  ensures { inv_marked_old_nexts2 marked nexts nexts[n] } = ()

(*
  Note intéressante :
  -------------------
  Je pense que ...
  La seule implication à démontrer est que tous les nombres non marqués
  sont premiers !
  Car à chaque fois qu'on marque un nombre, par définition, c'est qu'il est
  produit de deux entiers (nécessairement compris entre 2 et inférieurs au
  nombre marqué). ET DONC, ça nous donne directement l'implication
  marked[i] -> not prime i, ce qui nous donne donc prime i -> not marked[i] !
  Et donc tous les nombres premiers inférieures ou égaux à n seront
  nécessairement marqués !
  Il y a quand même une petite subtilité, il faut montrer qu'aucun des éléments
  sautés dans la liste chainée des éléments n'est pas marquée. Ce qui est
  facilement surmontable car à chaque fois on vérifie si le suivant est marqué
  pour pouvoir sauter par dessus.
*)

type st = private {
  ghost nexts: array int;
  ghost marked: array bool;
  max: int;
  mutable n: int
}
  invariant { nexts.length = marked.length = max + 1 }
  invariant { inv_remove_products nexts marked n }
  invariant { previously_marked_products marked n }
  invariant { only_products_marked marked n }
  invariant { inv_marked_nexts marked nexts }
  invariant { inv_marked_old_nexts2 marked nexts n }

  by { nexts = (Array.make 3 0)[0 <- 1][1 <- 2];
       marked = (Array.make 3 true)[2 <- false];
       max = 2; n = 2 }

predicate unchanged_elsewhere (a a_old: array 'a) (max i: int) =
  forall k. 0 <= k <= max -> k <> i -> a[k] = a_old[k]

predicate unchanged (a a_old: array 'a) (max: int) =
  unchanged_elsewhere a a_old max (-1)

val create (max: int) : st
  requires { max >= 2 }

val set_next (t: st) (i v: int) : unit
  requires { 0 <= i <= t.max }
  ensures { t.nexts[i] = v /\
            unchanged_elsewhere t.nexts (old t.nexts) t.max i }

val get_next (t: st) (i: int) : int
  requires { 0 <= i <= t.max }
  ensures { result = t.nexts[i] /\ unchanged t.nexts (old t.nexts) t.max }

val set_mark (t: st) (i: int) (v: bool) : unit
  requires { 0 <= i <= t.max }
  ensures { t.marked[i] = v /\
            unchanged_elsewhere t.marked (old t.marked) t.max i }

val get_mark (t: st) (i: int) : bool
  requires { 0 <= i <= t.max }
  ensures { result = t.marked[i] /\ unchanged t.marked (old t.marked) t.max }

let remove_products (nexts: array int) (marked: array bool)
                    (max: int) (n: int) : unit
  requires { 2 <= n <= max /\ n * n <= max }
  requires { nexts.length = marked.length = max + 1 }
  requires { inv_remove_products nexts marked n }
  requires { previously_marked_products marked n }
  requires { only_products_marked marked n }
  requires { inv_marked_nexts marked nexts }
  requires { inv_marked_old_nexts2 marked nexts n }
  ensures { inv_remove_products nexts marked n }
  ensures { inv_marked_nexts marked nexts }
  ensures { inv_marked_old_nexts2 marked nexts nexts[n] }
  ensures { previously_marked_products marked nexts[n] }
  ensures { only_products_marked marked nexts[n] }
  = let ghost marked_old = copy marked in
    assert { inv_marked_old_nexts1 marked_old nexts 0 };
    assert { inv_marked_old_nexts2 marked_old nexts n };
    assert { inv_marked_old_nexts2_partial marked nexts n n by
               inv_marked_old_nexts2 marked nexts n /\ n <= div max n by
               n * n <= max };
    assert { previously_marked_products marked_old n };
    assert { only_products_marked marked_old n };
    let rec loop (p: int) (ghost x: int) =
      requires { 1 <= p <= max /\ 2 <= n <= max /\
                 p <= x < nexts[p] /\ nexts[x] = nexts[p] /\ marked[n * n] }
      requires { inv_remove_products nexts marked n }
      requires { previously_marked_products marked n }
      requires { not marked[p] }
      requires { inv_marked_nexts marked nexts }
      requires { inv_marked_marked_old marked marked_old }
      requires { inv_marked_old_nexts1 marked_old nexts x }
      requires { inv_marked_old_nexts2 marked_old nexts n }
      requires { prime_products_marked marked_old marked n nexts[x] }
      requires { inv_marked_old_nexts2_partial marked nexts n p }
      requires { only_products_marked marked (n + 1) }
      ensures { inv_remove_products nexts marked n }
      ensures { inv_marked_nexts marked nexts }
      ensures { inv_marked_old_nexts2 marked nexts nexts[n] }
      ensures { inv_marked_marked_old marked marked_old }
      ensures { previously_marked_products marked n }
      ensures { prime_products_marked marked_old marked n marked.length }
      ensures { only_products_marked marked (n + 1) }
      variant { max - nexts[p] }
      let next = nexts[p] in
      if 0 <= next < max + 1 then
        if n * next <= max then begin
          conservation_only_products_marked marked (n + 1) n nexts[p];
          marked[n * nexts[p]] <- true;
          assert { n * nexts[p] < n * (nexts[p] + 1) };
          assert { n > 0 -> next >= 2 -> n * next >= n * 2 };
          assert { not marked[p] by n * nexts[p] > p by
                     p < 2 * p < 2 * nexts[p] <= n * nexts[p] by
                     nexts[p] >= 2 /\ n > 0 };
          assert { not marked_old[p] };
          assert { not marked_old[nexts[p]] by
                      2 <= p < next <= div max n by
                      n * next <= max };
          assert { prime_products_marked marked_old marked n nexts[next] };
          assert { forall i. 0 <= i < p -> nexts[i] <= p by
                     not marked[p] /\
                     forall i. 0 <= i < p ->
                               forall j. i < j < nexts[i] -> marked[j] by
                     inv_marked_nexts marked nexts };
          assert { inv_marked_old_nexts2_partial marked nexts n p by
                     n * nexts[p] > n * p >= 2 * p > p by
                     n >= 2 /\ nexts[p] > p /\ p >= 1 };
          if marked[next] then begin
            assert { inv_marked_nexts marked nexts };
            assert { inv_marked_old_nexts1 marked_old nexts x };
            assert { 0 <= p < marked.length };
            assert { nexts[p] <> marked.length };
            assert { marked[nexts[p]] };
            assert { inv_marked_old_nexts1 marked_old nexts next by x < next };
            nexts[p] <- nexts[next];
            assert { inv_marked_old_nexts1 marked_old nexts next by
                       p <= x < next };
            assert { prime_products_marked marked_old marked n next by
                       p < next };
            assert { 0 <= p < marked.length };
            assert { marked[next] };
            assert { not marked_old[p] by not marked[p] };
            assert { not marked_old[next] };
            assert { 2 <= p < next <= div max n by n * next <= max };
            assert { prime_products_marked marked_old marked n next };
            assert { nexts[p] > next };
            loop p next
          end else begin
            assert { forall i. p < i < nexts[p] -> marked[i] by
                       inv_marked_nexts marked nexts };
            loop next next
          end
        end else
          conservation_inv_marked_old_nexts2 marked nexts max n p
      else conservation_inv_marked_old_nexts2 marked nexts max n p in
      conservation_only_products_marked marked (n + 1) n n;
      marked[n * n] <- true;
      assert { forall i. 0 <= i < n -> nexts[i] <> n * n by
               forall i. 0 <= i < n -> nexts[i] <= n < n * n by
                 not marked[n] /\
                 forall i. 0 <= i < n ->
                           forall j. i < j < nexts[i] -> marked[j] by
                   inv_marked_nexts marked nexts };
      loop n n;
      prev_and_new_impl_all_products_marked marked_old marked n max;
      conservation_previously_marked_products marked nexts n

let lemma previously_marked_products_impl_prime (marked: array bool) (n: int)
  requires { 2 <= n < marked.length /\ not marked[n] }
  requires { previously_marked_products marked n }
  ensures { prime n } =
  assert { forall k.
             2 <= k < n ->
             not divides k n by
           forall k.
             2 <= k < n ->
             not (exists i. 2 <= i < marked.length /\ n = k * i) }

let lemma only_products_marked_impl_not_marked (marked: array bool)
                                               (nexts: array int)
                                               (n: int)
  requires { 2 <= n < marked.length }
  requires { only_products_marked marked nexts[n] }
  requires { prime n }
  ensures { not marked[n] } =
  assert { forall i j. 2 <= i < n -> 2 <= j < marked.length -> i * j <> n }


let euler_sieve (max: int) : array int
  requires { max >= 2 }
  ensures { all_differents result result.length }
  ensures { forall i. 0 <= i < result.length -> prime result[i] }
  ensures { forall i. 2 <= i <= max -> prime i ->
                      exists j. 0 <= j < result.length /\ result[j] = i }
= let nexts = make (max + 1) 0 in
  let marked = make (max + 1) false in
  for i = 0 to max do
    invariant { inv_nexts nexts i }
    invariant { forall j. 0 <= j < i -> nexts[j] = j + 1 }
    nexts[i] <- i + 1;
  done;
  marked[0] <- true; marked[1] <- true;
  let rec loop (n: int) =
    requires { 2 <= n <= max + 1 }
    requires { n <> max + 1 /\ n * n <= max }
    requires { previously_marked_products marked n }
    requires { only_products_marked marked n }
    requires { inv_marked_nexts marked nexts }
    requires { inv_marked_old_nexts2 marked nexts n }
    requires { inv_remove_products nexts marked n }
    ensures { inv_nexts nexts nexts.length }
    ensures { inv_marked_nexts marked nexts }
    ensures { forall i. 0 <= i < marked.length -> not marked[i] <-> prime i }
    variant { max + 1 - n }
      remove_products nexts marked max n;
      if nexts[n] * nexts[n] <= max then begin
        assert { all_primes marked n /\ not marked[n] /\
                 nexts[n] <= div max nexts[n] };
        previously_marked_products_impl_prime marked nexts[n];
        loop nexts[n]
      end else begin
        not_prime_impl_divisor_under_sqrt nexts[n];
        assert { forall i.
                   2 <= i < marked.length ->
                   not marked[i] ->
                   not (exists k l. 2 <= k < nexts[n] /\ 2 <= l < i /\
                                    k * l = i) by
                 previously_marked_products marked nexts[n] };
        no_prod_impl_no_divider nexts[n];
        assert { forall i. 2 <= i < marked.length ->
                           not marked[i] ->
                           prime i by
                 forall i.
                  2 <= i < marked.length ->
                  not marked[i] ->
                  (not (exists k. 2 <= k < nexts[n] /\ k <> i /\ divides k i) by
                  i < nexts[n] * nexts[n]) }
      end in
  if max >= 4 then loop 2;
  let rec count (p: int) (cnt: int) =
    requires { 2 <= p <= max }
    requires { 1 <= cnt <= p - 1 }
    requires { inv_count nexts marked cnt }
    requires { all_differents nexts cnt }
    requires { all_inf_or_eq nexts cnt p }
    requires { forall i. 0 <= i < cnt -> prime nexts[i] }
    requires { forall i. 2 <= i < nexts[p] -> prime i ->
                         exists j. 0 <= j < cnt /\ nexts[j] = i }
    ensures { 1 <= result <= max }
    ensures { all_differents nexts result }
    ensures { forall i. 0 <= i < result -> prime nexts[i] }
    ensures { forall i. 2 <= i <= max -> prime i ->
                        exists j. 0 <= j < result /\ nexts[j] = i }
    variant { max + 1 - nexts[p] }
    let next = nexts[p] in
    if next = max + 1 then begin cnt end
    else
      let ghost copy = sub nexts 0 cnt in
      if marked[next] then begin
        assert { forall j. next < j < nexts[next] -> not prime j by
                           next > p > cnt };
        assert { forall i. 2 <= i < next -> prime i ->
                           exists j. 0 <= j < cnt /\ nexts[j] = i };
        nexts[p] <- nexts[next];
        assert { forall i. 0 <= i < cnt -> nexts[i] = copy[i] };
        assert { forall i. cnt <= i < marked.length ->
                           forall j. i < j < nexts[i] ->
                                     marked[j] by
                 forall j. p < j < nexts[p] -> marked[j] };
        count p cnt
      end else begin
        (*
          Attention : des fois j'ai des bonnes idées ! ...
          On réécrit le début du tableau nexts !
          Parce que le nombre de nombres premiers <= n est strictement
          inférieur à n !
          Du coup on peut réécrire le tableau nexts en recopiant
          consécutivement les nombres premiers déja rencontrés et ceci ne
          modifiera pas les calculs de count par la suite
        *)
        nexts[cnt] <- next; (* une opération en plus ... *)
        assert { (forall i. 0 <= i < cnt -> nexts[i] = copy[i]) /\
                 (forall i. next < i < nexts[next] -> not prime i) /\
                 forall i. 2 <= i < next -> prime i ->
                           exists j. 0 <= j < cnt /\ nexts[j] = i };
        count next (cnt + 1)
      end in
  nexts[0] <- 2;
  sub nexts 0 (count 2 1)

end
