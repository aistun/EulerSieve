module EulerSieve

use int.Int
use int.EuclideanDivision
use array.Array
use array.NumOf
(*
predicate nexts_croissance (a: array int) =
  forall i. 0 <= i < a.length - 1 -> a[i] < a[i + 1]

predicate nexts_borne (a: array int) =
  forall i. 0 <= i < a.length -> i < a[i] <= a.length*)
  (*
function nb_multiples_unmarked (a: array bool) (n: int) (l: int) : int =
  numof (fun i x -> not x /\ mod i n = 0) a 0 l*)

(* predicate multiples_unmarked (marked: array bool) (n: int) (next: int) = *)
(*   next >= n /\ forall i. n * next <= n * i < marked.length -> not marked[n * i] *)
(*
lemma multiples_unmarked_croissance:
  forall marked n l.
    0 <= l < marked.length - 1 ->
    0 <= n < marked.length ->
    if mod l n = 0 then
      if marked[l] then
        nb_multiples_unmarked marked n (l + 1) = nb_multiples_unmarked marked n l
      else
        nb_multiples_unmarked marked n (l + 1) = 1 + nb_multiples_unmarked marked n l
    else
      nb_multiples_unmarked marked n (l + 1) = nb_multiples_unmarked marked n l

lemma mutliples_unmarked_croissance_borne:
  forall marked n l.
    0 <= l < marked.length - 1 ->
    0 <= n < marked.length ->
    nb_multiples_unmarked marked n l <= nb_multiples_unmarked marked n (l + 1) <= 1 + nb_multiples_unmarked marked n l 
*)
  (*
lemma divide_desc:
  forall n l. 
    0 <= n <= l ->
    mod (l + 1) n = 0 -> exists k r. 0 <= k < l /\ 0 <= r < n /\ l = (k - 1) * n + r*)
(*
lemma div_croissance:
  forall l n.
    0 <= n < l ->
    divides (l + 1) n -> div (l + 1) n = 1 + div l n*)

(* lemma mutliples_unmarked_local_borne:
  forall marked n l.
    0 <= l < marked.length - 1 ->
    0 <= n < marked.length ->
    nb_multiples_unmarked marked n l <= div l n ->
    nb_multiples_unmarked marked n (l + 1) <= div (l + 1) n

let rec lemma multiples_unmarked_borne (marked: array bool) (n: int) (l: int)
  requires { 0 <= n < marked.length }
  requires { 0 <= l < marked.length }
  ensures { 0 <= nb_multiples_unmarked marked n l <= marked.length }
= variant { l }
  if l = 0 then ()
  else multiples_unmarked_borne marked n (l - 1) *)
  
(* lemma a:
  forall l n. 
    l > 0 -> n > 1 -> mod l n = 0 <-> mod (l - 1) n = n - 1 *)
    
(* function nb_multiples_unmarked (marked: array bool) (n: int) (m: int) : int = *)
(*   numof (fun i x -> not x /\ mod i n = 0) marked 0 marked.length *)

(* predicate next_multiples_unmarked (a: array bool) (n: int) (m: int) = *)
(*   2 <= n <= m < a.length -> *)
(*   forall i. m <= i < a.length -> *)
(*             i * n < a.length -> *)
(*             a[i * n] = false *)
    
(* lemma a: *)
(*   forall marked n m. *)
(*     2 <= n <= m < marked.length -> marked[m] = false -> m * n < marked.length -> *)
(*     next_multiples_unmarked marked n m -> marked[n * m] = false *)
    
(* lemma a2: *)
(*   forall marked n m. *)
(*     2 <= n <= m < marked.length -> marked[m] = true -> m * n < marked.length -> *)
(*     next_multiples_unmarked marked n m -> marked[n * m] = false *)
        
(* lemma b: *)
(*   forall marked n m. *)
(*     not marked[n * m] -> nb_multiples_unmarked marked n m = nb_multiples_unmarked marked n (m + 1) *)

predicate inv_remove_products (nexts: array int) (marked: array bool) =
  nexts.length = marked.length /\
  forall i. 0 <= i < nexts.length ->
            i < nexts[i] <= nexts.length

let rec remove_products (nexts: array int) (marked: array bool)
                        (max: int) (n: int) (p: int) : unit
  requires { 2 <= p <= max + 1 /\ 2 <= n <= max }
  requires { nexts.length = marked.length = max + 1 }
  requires { inv_remove_products nexts marked }
  = let rec loop p =
    requires { 0 <= p <= max }
    requires { 2 <= n <= max }
    requires { inv_remove_products nexts marked }
    ensures { inv_remove_products nexts marked }
    variant { max - nexts[p] }
    let next = nexts[p] in
    if 0 <= next < max + 1 then
      if n * next <= max then begin
        marked[n * next] <- true;
        if marked[next] then begin
          nexts[p] <- nexts[next];
          loop p
        end else
          loop next
      end in
    if n * n <= max then begin
      marked[n * n] <- true;
      loop n
    end

let euler_sieve (max: int) : array int
= let nexts = make (max + 1) 0 in
  let marked = make (max + 1) false in
  (* finalement, on ne met pas nexts[max] = -1, mais nexts[max] = max + 1,
     plus facile Ã  prouver pour la terminaison *)
  for i = 0 to max do
     nexts[i] <- i + 1
  done;
  let rec loop n =
    variant { max + 1 - n }
    if n <> max + 1 then begin
      remove_products nexts marked max n (-1);
      loop nexts[n]
    end in
  loop 2;
  let rec count p cnt =
    variant { max - p }
    let next = nexts[p] in
    if next = max + 1 then cnt
    else
      if marked[next] then begin
        nexts[p] <- nexts[next];
        count p cnt
      end else
        count next (cnt + 1) in
  let primes = make (count 1 0) 0 in
  let ref p = 0 in
  let ref i = 2 in
  while i <> max + 1 do
    if not marked[i] then begin
      primes[p] <- i;
      p <- p + 1
    end;
    i <- nexts[i]
  done;
  primes

end
