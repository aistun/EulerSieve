module EulerSieve

use int.Int
use array.Array
use array.NumOf

predicate nexts_croissance (a: array int) =
  forall i. 0 <= i < a.length - 1 -> a[i] < a[i + 1]

predicate nexts_borne (a: array int) =
  forall i. 0 <= i < a.length -> i < a[i] <= a.length
  
(*function nb_unmarked (a: array bool) : int =
  numof (fun i x -> not x) a 0 a.length

predicate multiples_unmarked (marked: array bool) (n: int) (next: int) =
  next >= n /\ forall i. n * next <= n * i < marked.length -> not marked[n * i] *)
  
predicate has_pred (nexts: array int) (n: int) =
  exists i. 0 <= i < nexts.length /\ nexts[i] = n
  
predicate unique_preds (nexts: array int) =
  forall i j. nexts[i] = nexts[j] -> i = j

function nb_preceded_numbers (nexts: array int) : int =
  numof (fun i x -> has_pred nexts i) nexts 0 nexts.length
  
lemma a: 
  forall a. nexts_borne a -> 
            nexts_croissance a -> 
            forall i. 0 <= i < a.length - 2 -> a[i] < a[a[i]]

let rec remove_products (nexts: array int) (marked: array bool)
                        (max: int) (n: int) (p: int) : unit
  (* requires { max_calls >= nb_unmarked marked } *)
  requires { 2 <= p <= max + 1 /\ 2 <= n <= max }
  requires { nexts.length = max + 1 /\ marked.length = max + 1 }
  requires { nexts_borne nexts }
  requires { nexts_croissance nexts }
  requires { unique_preds nexts }
  (* requires { forall i. 0 <= i < nexts.length -> nexts[i] > i } *)
  (* requires { forall i. 0 <= i < nexts.length -> 0 <= nexts[i] <= max } *)
  (* requires { 0 <= nb_marked marked <= max } *)
= (* variant { max - nb_marked marked } *)
   (* C'EST QUAND MEME VRAIMENT ELEGANT !!! *)
  let rec loop p =
    requires { 2 <= p <= max }
    requires { nexts_borne nexts }
    requires { unique_preds nexts }
    variant { max + 1 - p + nb_preceded_numbers nexts }
    let next = (*if p = max + 1 then n else nexts[p]*) nexts[p] in
    if 0 <= next < max + 1 then
      if n * next <= max then begin
        marked[n * next] <- true;
        if (*p < max + 1 &&*) marked[next] then begin
          nexts[p] <- nexts[next[p]];
          loop p
        end else
          loop next
      end in
    if n * n <= max then begin
      marked[n * n] <- true;
      loop n
    end

let euler_sieve (max: int) : array int
= let nexts = make (max + 1) 0 in
  let marked = make (max + 1) false in
  (* finalement, on ne met pas nexts[max] = -1, mais nexts[max] = max + 1,
     plus facile Ã  prouver pour la terminaison *)
  for i = 0 to max do
     nexts[i] <- i + 1
  done;
  let rec loop n =
    variant { max + 1 - n }
    if n <> max + 1 then begin
      remove_products nexts marked max n (-1);
      loop nexts[n]
    end in
  loop 2;
  let rec count p cnt =
    variant { max - p }
    let next = nexts[p] in
    if next = max + 1 then cnt
    else
      if marked[next] then begin
        nexts[p] <- nexts[next];
        count p cnt
      end else
        count next (cnt + 1) in
  let primes = make (count 1 0) 0 in
  let ref p = 0 in
  let ref i = 2 in
  while i <> max + 1 do
    if not marked[i] then begin
      primes[p] <- i;
      p <- p + 1
    end;
    i <- nexts[i]
  done;
  primes

end
