\documentclass[a4paper]{easychair}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{todonotes}
\usepackage{./why3lang}

% \pagestyle{empty} % pour la version finale EasyChair

\begin{document}

\title{...}
\titlerunning{...}
\author{Josué Moreau\thanks{Ce travail a été effectué dans le cadre
    d'un stage de L3 à l'Université Paris-Saclay, du 1er au 30 juin
    2020, encadré à distance par Jean-Christophe Filliâtre.}}
\authorrunning{Josué Moreau}
\institute{Université Paris-Saclay}
\maketitle

\begin{abstract}
  Dans cet article, ...
\end{abstract}

\section{Introduction}

% contexte : ce qu'est Why3 ; ce qu'est le crible d'Euler~\cite{crible-euler} ;
% pourquoi est-il intéressant d'en faire une preuve formelle

Le crible d'Euler, tout comme le crible d'Ératosthène, permet d'énumérer
l'ensemble des nombres premiers compris entre 2 et une limite donnée $N$.
Le crible d'Euler a une complexité temporelle en $O(N)$ pour énumérer tous les
nombres premiers dans l'ensemble $\{2,...,N\}$~\cite{crible-euler} alors que celui
d'Ératosthène a une complexité $O(\log\log N)$.

Cette amélioration de complexité engendre quelques subtilités dans l'implémentation
du crible d'Euler. Ce sont ces subtilités qui rendent la tâche de vérification
formelle plus compliquée que pour le crible d'Ératosthène et qui rend donc la
preuve intéressante.


L'intégralité de la preuve Why3 est disponible en ligne~\cite{mapreuve}.

Cet article est organisé de la façon suivante.
% La section~\ref{...} décrit ceci...
% La section~\ref{...} décrit cela...

\section{Le crible d'Euler}

% présentation de l'algorithme du crible d'Euler

L'algorithme du crible d'Euler prend comme unique entrée la limite $N \geq 2$ et va
renvoyer tous les nombres premiers compris entre $2$ et $N$. Il se divise en
deux parties. La première partie prend un nombre $n$ non marqué
tel que $2 \leq n \leq N$ et va marquer tous les multiples $np$ tels que
$2 \leq np \leq N$ et $p \geq n$ n'est pas marqué. Elle correspond à la fonction
\ocamlf{remove_products} de la figure~\ref{fig:codeOCaml}.
La deuxième partie de l'algorithme boucle sur un entier $n$ et appelle à chaque
tour de boucle la fonction \ocamlf{remove_products} puis affecte $n$ au plus
petit entier inférieur à la limite, non marqué et strictement supérieur à $n$
et recommence tant que $2 \leq n \leq N$.

À la fin de chaque étape de la boucle principale, tous les produits de $n$ sont
marqués. En effet, en supposant que pour tout $2 \leq k < n$, les multiples de $k$
sont déjà marqués, l'appel de \ocamlf{remove_products} marque tous les produits
$np$ tels que $p \geq n$ n'est pas marqué. Si un $p \geq n$ était déjà marqué,
alors, par définition du marquage, il existe un $i$ non marqué et $j$ tel que
$2 \leq i < n$, $2 \leq j < p$ et $ij = p$. Or, comme tous les multiples de $i$
étaient déjà marqués avant l'appel de \ocamlf{remove_products}, $ijn = pn$
a déjà été marqué, au plus tard lors de l'appel de \ocamlf{remove_products} sur
l'entier $i$.
Ainsi, l'algorithme ne marquant que les produits de nombres non marqués, il ne
marque qu'une seule fois chaque entier non premier, comme multiple de
son plus petit facteur premier. C'est là la clé de la complexité
linéaire du crible d'Euler.

% L'implémentation de l'algorithme que nous allons prouver se trouve dans la
% figure~\ref{fig:codeOCaml}. Dans celle-ci, nous utilisons une liste chaînée
% dans un tableau d'entiers pour représenter l'ensemble des entiers sur lesquels
% le crible sera appliqué.

% 1. idée d'utiliser une liste chaînée
L'implémentation de l'algorithme que nous allons prouver utilise une liste
chaînée croissante pour représenter les nombres de l'ensemble $\{2,...,N\}$.
Cette liste est importante pour que la représentation soit efficace car elle
permet d'obtenir efficacement le prochain entier
% en un temps amorti constant ?
en évitant de parcourir plus d'une fois un entier déjà marqué.
% 2. elle est simplement chaînée = un tableau next
De plus, elle est représentée dans un tableau d'entiers, elle est donc
simplement chaînée.

% 3. on marque un élément mais on le supprimera de la liste seulement
%    plus tard, quand on passera dessus (car on aura alors l'élément
%    précédent dans une variable, pour effectuer la suppression)
% 4. le marquage se fait dans ce même tableau next, en utilisant des
% valeurs négatives
Pour chaque case $i$, sa case correspondante contient un entier positif
si et seulement si l'entier $i$ est non marqué.
Ainsi, l'opération de marquage d'un entier non marqué consiste à remplacer le
contenu de la case d'index correspondant à l'entier à marquer par son opposé.
De plus, lorsqu'un nombre $i$ est non marqué, le contenu de sa case est son
suivant dans la liste chaînée.
Lors du marquage, on ne supprime pas l'entier marqué de la liste chaînée car
cela coûterait trop chère en temps, ou nécessiterait une liste doublement
chaînée. Au lieu de cela, la boucle de la fonction \ocamlf{remove_products}
utilise une variable $p$ qui représente le dernier entier visité.
Lorsqu'elle visite un nouvel entier $i$, elle marque $ni$, où $n$ est
l'entier dont on veut marquer tous les multiples.
Puis, si le nombre $i$ était marqué, elle modifie la case représentant $p$ en lui
donnait pour valeur le nombre suivant $i$. Cette opération permet à la liste
chaînée de ``sauter'' par dessus les entier déjà marqués, et donc n'examiner
qu'une seule fois chaque entier marqué.
Il est tout à fait possible de marquer le multiple $ni$ alors que $i$ est marqué,
le seul cas où cela est possible est lorsque $i$ est lui-même un multiple de $n$.

% 5. les valeurs paires ne sont pas représentées
Afin de diviser l'espace utilisé par deux, le tableau ne représente que les nombres
impairs, ainsi la case d'index $i$ du tableau représente l'entier $2i + 1$.
Pour chaque index $i$, la case $i$ contient un entier positif si et
seulement si l'entier $2i + 1$ n'est pas marqué.
De plus, si l'entier qu'elle contient est positif, il s'agit de l'entier suivant
dans la liste chaînée.

L'implémentation de l'algorithme que nous allons prouver se trouve dans la
figure~\ref{fig:codeOCaml}.

\begin{figure}[tp]
\begin{ocaml}
type t = { arr: int array; max: int; max_arr: int }

let create max =
  let len_arr = (max - 1) / 2 + 1 in
  let arr = Array.make len_arr (-2) in
  for i = 1 to len_arr - 1 do
    arr.(i) <- if i = len_arr - 1 then max + 1 else 2 * i + 3
  done;
  { arr = arr; max = max; max_arr = (max - 1) / 2 }

let set_next t i v = t.arr.(i / 2) <- v
let get_next t i = if t.arr.(i / 2) < 0 then - t.arr.(i / 2) else t.arr.(i / 2)
let set_mark t i = if t.arr.(i / 2) >= 0 then t.arr.(i / 2) <- - t.arr.(i / 2)
let get_mark t i = t.arr.(i / 2) < 0
let get_max t = t.max

let remove_products t n =
  let d = get_max t / n in
  let rec loop (p: int) : unit =
    let next = get_next t p in
    if 0 <= next && next <= get_max t then begin
      if next <= d then begin
        set_mark t (n * next);
        if get_mark t next then begin set_next t p (get_next t next); loop p end
        else loop next
      end end in
  set_mark t (n * n); loop n

let euler_sieve max =
  let t = create max in
  let rec loop n =
    remove_products t n;
    let nn = get_next t n in
    if nn <= max / nn then loop nn in
  if max >= 9 then loop 3;
  let cnt = ref 1 in
  let p = ref 1 in t.arr.(0) <- 2;
  while 2 * !p + 1 <= max do
    let next = t.arr.(!p) / 2 in
    if next <= t.max_arr then
      if t.arr.(next) < 0 then t.arr.(!p) <- - t.arr.(next)
      else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := next end
    else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := t.max_arr + 1 end
  done;
  Array.sub t.arr 0 !cnt
\end{ocaml}
\caption{Un code OCaml du crible d'Euler.}
\label{fig:codeOCaml}
\end{figure}

\section{Une vérification formelle avec Why3}

% décrire la preuve ici, montrer les morceaux intéressants
% (dont la spec de la fonction principale)

% le lemme intéressant qui permet d'affirmer à un certain stade que tous les
% multiples d'un nombre sont bien marqués

La preuve que décrite ici a été intégralement réalisée avec l'outil
Why3~\cite{why3} et les démonstrateurs automatiques Alt-Ergo, CVC4, Z3, Eprover
et Vampire. % il faut les citer eux aussi ? et leurs version ? pas forcément

\paragraph{Spécification.}
La spécification de la fonction principale du crible,
\ocamlf{euler_sieve}, est la suivante :

\begin{why3}
let euler_sieve (max: int63) : array63
  requires { max_int > max >= 3 }
  ensures  { forall i j. 0 <= i < j < result.length -> result[i] <> result[j] }
  ensures  { forall i. 0 <= i < result.length -> 2 <= result[i] <= max }
  ensures  { forall i. 0 <= i < result.length -> prime result[i] }
  ensures  { forall i. 2 <= i <= max -> prime i ->
                       exists j. 0 <= j < result.length /\ result[j] = i }
= ...
\end{why3}

% TODO expliquer d'où vient le prédicat "prime" (la bibliothèque
% number.Prime de Why3, déjà utilisée pour la preuve d'autres
% programmes manipulant des nombres premiers, comme le crible
% d'Ératosthène~\cite{EratostheneWhy3,KnuthPrimeNumbersWhy3})

Le prédicat \whyf{prime} provient de la bibliothèque \whyf{number.Prime}
de Why3. Il a déjà été utilisé dans les preuves d'autres programmes
manipulant des nombres premiers, comme le crible
d'Ératosthène~\cite{sieve-eratosthene-why3} ou celui de l'algorithme
des nombres premiers de Knuth~\cite{knuth-prime-numbers,knuth-prime-numbers-why3}.

% TODO plutôt 3 <= max < max_int ... oui mais faut refaire la preuve :'(

% expliquer int63 (une phrase) et array63 (une phrase)
% expliquer max_int > max
Le types \whyf{int63} est une modélisation Why3 des entiers OCaml qui sont
des entiers 63 bits signés. \whyf{array63} est le type d'un tableau indexé
par des entiers OCaml et contenant des entiers OCaml.
Afin de représenter $\{0,...,N\}$ il faut $N + 1$ cases dans un tableau.
Or, la longueur de ce tableau doit aussi être de type \whyf{int63}, ainsi
la longueur est inférieure ou égale à \whyf{max_int}. Pour respecter
cette contrainte, il faut donc que \whyf{max < max_int}.

% ET ... Je viens de me dire que la spec ne dit pas qu'on ne peut pas avoir
% de nombres premiers plus grands que la limite dans l'ensemble en résultat !


\paragraph{Vérification.}

La première partie de la preuve a consisté à démontrer l'algorithme sans prendre
en compte les éventuels débordements arithmétiques et avec des structures
de données simples et peu efficaces en terme de complexité spatiale.
L'étape suivante a consisté en un raffinement de la preuve établie précédemment
en cachant les structures de données naïves à l'aide de code
fantôme~\cite{ghost-code} et en liant ces structures de données à des structures
plus efficaces grâce à des invariants de liaison. Ces structures de données plus
efficaces n'étant, par la suite, accessibles qu'en utilisant des fonctions
\ocamlf{get/set}. Grâce à ces fonctions, il n'a donc pas été
nécessaire de reprouver l'intégralité de la preuve, simplement de montrer la
conservation des invariants de liaison par ces fonctions \ocamlf{get/set}.
Enfin, la dernière partie de la preuve a consisté en l'utilisation d'entiers
machine 63 bits signés tels que ceux d'OCaml, pour prouver l'absence de
débordements arithmétiques.


La preuve a nécessité l'écriture de 748 lignes dans le langage WhyML :
507 lignes pour la spécification et 241 lignes de code.
Au total, 834 buts on été prouvés.
    % spec     code comments
    %  507      241       33 euler_sieve.mlw

    %  éventuellement intégrer les stats de why3 session info --stats

quelques éléments quantitatifs ici
- combien de lignes écrites pour les besoins de la preuve
- degré d'automatisation de la preuve
- quel temps de travail (approximativement)
- etc.

\section{Le code OCaml extrait de la preuve}

Le code extrait de la preuve à l'aide de la commande \texttt{extract} de Why3
est en réalité celui présenté à la figure~\ref{fig:codeOCaml}.
Seules quelques modifications dans l'apparence du code ont été effectuées
entre le code extrait et le code présenté.

à quoi ressemble-t-il ?
est-il efficace ?

\begin{center}
  \begin{tabular}{|c|r|r|}
    \hline
    $N$ & temps de calcul & mémoire utilisée \\
    \hline\hline
    $10^6$ &  0,021 s &      8 Mo \\\hline
    $10^7$ &  0,139 s &     73 Mo \\\hline
    $10^8$ &  1,880 s &    721 Mo \\\hline
    $10^9$ & 14,500 s & 7\,200 Mo \\\hline
  \end{tabular}
\end{center}

\section{Conclusion}
\label{sec:conclusion}

une brève conclusion = résumé de ce qui a été présenté

perspectives
- prouver que la complexité est linéaire
- prouver un crible segmenté~\cite{crible-segmente}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Remerciements.} ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}


% Local Variables:
% compile-command: "make"
% ispell-local-dictionary: "francais"
% End:
