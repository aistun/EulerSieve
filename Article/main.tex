\documentclass[a4paper]{easychair}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{todonotes}
\usepackage{./why3lang}

% \pagestyle{empty} % pour la version finale EasyChair

\begin{document}

\title{...}
\titlerunning{...}
\author{...}
\authorrunning{...}
\institute{Université Paris-Saclay}
\maketitle

\begin{abstract}
  Dans cet article, ...
\end{abstract}

\section{Introduction}

contexte : ce qu'est Why3 ; ce qu'est le crible d'Euler~\cite{crible-euler} ; pourquoi
est-il intéressant d'en faire une preuve formelle

L'intégralité de la preuve Why3 est disponible en ligne~\cite{mapreuve}.

Cet article est organisé de la façon suivante.
La section~\ref{...} décrit ceci...
La section~\ref{...} décrit cela...

\section{Le crible d'Euler}

Le crible d'Euler, tout comme le crible d'\'{E}ratosthène, permet d'énumérer
l'ensemble des nombres premiers compris entre 2 et une limite donnée $N$.
Le crible d'Euler a une complexité temporelle en $O(N)$ pour énumérer tous les
nombres premiers dans l'ensemble $\{2,...,N\}$~\cite{crible-euler} alors que celui
d'\'{E}ratosthène est quand à lui de complexité $O(\log\log N)$.

montrer l'implémentation choisie, en OCaml
dans la figure~\ref{fig:codeOCaml}

\begin{figure}[tp]
\begin{ocaml}
type t = { arr: int array; max: int; max_arr: int }

let create max =
  let len_arr = (max - 1) / 2 + 1 in
  let arr = Array.make len_arr (-2) in
  for i = 1 to len_arr - 1 do
    arr.(i) <- if i = len_arr - 1 then max + 1 else 2 * i + 3
  done;
  { arr = arr; max = max; max_arr = (max - 1) / 2 }

let set_next t i v = t.arr.(i / 2) <- v
let get_next t i = if t.arr.(i / 2) < 0 then - t.arr.(i / 2) else t.arr.(i / 2)
let set_mark t i = if t.arr.(i / 2) >= 0 then (t.arr).(i / 2) <- - t.arr.(i / 2)
let get_mark t i = t.arr.(i / 2) < 0
let get_max t = t.max

let remove_products t n =
  let d = get_max t / n in
  let rec loop p =
    let next = get_next t p in
    if 0 <= next && next <= get_max t then begin
      if next <= d then begin
        set_mark t (n * next);
        if get_mark t next then begin set_next t p (get_next t next); loop p end
        else loop next
      end end in
  set_mark t (n * n); loop n

let euler_sieve max =
  let t = create max in
  let rec loop (n: int) : unit =
    remove_products t n;
    let nn = get_next t n in
    if nn <= max / nn then loop nn in
  if max >= 9 then loop 3;
  let cnt = ref 1 in
  let p = ref 1 in (t.arr).(0) <- 2;
  while 2 * !p + 1 <= max do
    let next = (t.arr).(!p) / 2 in
    if next <= t.max_arr then
      if (t.arr).(next) < 0 then (t.arr).(!p) <- - (t.arr).(next)
      else begin (t.arr).(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := next end
    else begin (t.arr).(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := t.max_arr + 1 end
  done;
  Array.sub t.arr 0 !cnt
\end{ocaml}
\caption{Un code OCaml du crible d'Euler.}
\label{fig:codeOCaml}
\end{figure}

\section{Une vérification formelle avec Why3}

décrire la preuve ici, montrer les morceaux intéressants
(dont la spec de la fonction principale)

\begin{why3}
  let f (x: int) : int
    requires { x > 0 }
  =
    x + 1
\end{why3}

quelques éléments quantitatifs ici
- combien de lignes écrites pour les besoins de la preuve
- degré d'automatisation de la preuve
- quel temps de travail (approximativement)
- etc.

\section{Le code OCaml extrait de la preuve}

à quoi ressemble-t-il ?
est-il efficace ?

\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    $N$ & temps de calcul & mémoire utilisée \\
    \hline\hline
    $10^6$ & 10 s & 1 Go \\\hline
    $10^7$ & \\\hline
    $10^8$ & \\\hline
    $10^9$ & \\\hline
  \end{tabular}
\end{center}

\section{Conclusion}
\label{sec:conclusion}

une brève conclusion = résumé de ce qui a été présenté

perspectives
- prouver que la complexité est linéaire
- prouver un crible segmenté~\cite{crible-segmente}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Remerciements.} ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}


% Local Variables:
% compile-command: "make"
% ispell-local-dictionary: "francais"
% End:
