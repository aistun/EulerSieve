\documentclass[a4paper]{easychair}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{todonotes}
\usepackage{./why3lang}

% \pagestyle{empty} % pour la version finale EasyChair

\begin{document}

\title{...}
\titlerunning{...}
\author{Josué Moreau}
\authorrunning{Josué Moreau}
\institute{Université Paris-Saclay}
\maketitle

\begin{abstract}
  Dans cet article, ...
\end{abstract}

\section{Introduction}

% contexte : ce qu'est Why3 ; ce qu'est le crible d'Euler~\cite{crible-euler} ;
% pourquoi est-il intéressant d'en faire une preuve formelle

Le crible d'Euler, tout comme le crible d'\'{E}ratosthène, permet d'énumérer
l'ensemble des nombres premiers compris entre 2 et une limite donnée $N$.
Celui-ci a une complexité temporelle en $O(N)$ pour énumérer tous les
nombres premiers dans l'ensemble $\{2,...,N\}$~\cite{crible-euler} alors que celui
d'\'{E}ratosthène est quand à lui de complexité $O(\log\log N)$.

Cette amélioration de complexité engendre quelques subtilités dans l'implémentation
du crible d'Euler, ce sont ces subtilités qui rendent la tache de vérification
formelle plus compliquée que pour le crible d'{E}ratosthène et qui rend donc la
preuve intéressante.






L'intégralité de la preuve Why3 est disponible en ligne~\cite{mapreuve}.

Cet article est organisé de la façon suivante.
% La section~\ref{...} décrit ceci...
% La section~\ref{...} décrit cela...

\section{Le crible d'Euler}

% présentation de l'algorithme du crible d'Euler

L'algorithme du crible d'Euler comme unique entrée la limite $N \geq 2$ et va
renvoyer tous les nombres premiers compris entre $2$ et $N$ et il se divise en
deux parties. La première partie prend un nombre $n$ non marqué
tel que $2 \leq n \leq N$ et va marquer tous les nombres $n * p$ tels que
$2 \leq n * p \leq N$ et $p \geq n$ n'est pas marqué, elle correspond à la fonction
\ocamlf{remove_products} de la figure~\ref{fig:codeOCaml}.
La deuxième partie de l'algorithme boucle sur un entier $n$ et appelle à chaque
tour de boucle la fonction \ocamlf{remove_products} puis affecte $n$ au plus
petit entier inférieur à la limite, non marqué et strictement supérieur à $n$
et recommence tant que $2 \leq n \leq N$.

A la fin de chaque étape de la boucle principale tous les produits de $n$ sont
marqués. En effet, en supposant que pour tout $2 \leq k < n$, les multiples de $k$
sont déjà marqués, l'appel de \ocamlf{remove_products} marque tous les produits
$n * p$ tels que $p \geq n$ n'est pas marqué. Si un $p \geq n$ était déjà marqué,
alors, par définition du marquage, il existe un $i$ non marqué et $j$ tel que
$2 <= i < n$, $2 <= j < p$ et $i * j = p$. Or, comme tous les multiples de $i$
étaient déjà marqués avant l'appel de \ocamlf{remove_products}, $i * j * n = p * n$
a déjà été marqué, au plus tard, lors de l'appel de \ocamlf{remove_products} sur
l'entier $i$.

Ainsi, l'algorithme ne marquant que les produits de nombres non marqués, il ne
marque qu'une seule fois chaque entier non premier.

L'implémentation de l'algorithme que nous allons prouver se trouve dans la
figure~\ref{fig:codeOCaml}. Dans celle-ci, nous utilisons une liste chaînée
dans un tableau d'entiers pour représenter l'ensemble des entiers sur lesquels
le crible sera appliqué.
Afin de diviser l'espace utilisé par deux, le tableau ne représente que les nombres
impairs, ainsi la case d'index $i$ du tableau représente l'entier $2 * i + 1$.
Pour chaque index $i$, la case $i$ contient un entier positif si et
seulement si l'entier $2 * i + 1$ n'est pas marqué.
De plus, si l'entier qu'elle contient est positif, il s'agit du plus
petit entier non marqué $k$ tel que $k > 2 * i + 1$.

% sans doute très mal exprimé ...
Enfin, à chaque fois qu'un entier $k$ est marqué, le contenu de sa case est passé
en négatif et la case qui pointait vers cet entier $k$ est modifié pour pointer
vers l'entier pointé par la case $k$.

\begin{figure}[tp]
\begin{ocaml}
type t = { arr: int array; max: int; max_arr: int }

let create max =
  let len_arr = (max - 1) / 2 + 1 in
  let arr = Array.make len_arr (-2) in
  for i = 1 to len_arr - 1 do
    arr.(i) <- if i = len_arr - 1 then max + 1 else 2 * i + 3
  done;
  { arr = arr; max = max; max_arr = (max - 1) / 2 }

let set_next t i v = t.arr.(i / 2) <- v
let get_next t i = if t.arr.(i / 2) < 0 then - t.arr.(i / 2) else t.arr.(i / 2)
let set_mark t i = if t.arr.(i / 2) >= 0 then t.arr.(i / 2) <- - t.arr.(i / 2)
let get_mark t i = t.arr.(i / 2) < 0
let get_max t = t.max

let remove_products t n =
  let d = get_max t / n in
  let rec loop (p: int) : unit =
    let next = get_next t p in
    if 0 <= next && next <= get_max t then begin
      if next <= d then begin
        set_mark t (n * next);
        if get_mark t next then begin set_next t p (get_next t next); loop p end
        else loop next
      end end in
  set_mark t (n * n); loop n

let euler_sieve max =
  let t = create max in
  let rec loop n =
    remove_products t n;
    let nn = get_next t n in
    if nn <= max / nn then loop nn in
  if max >= 9 then loop 3;
  let cnt = ref 1 in
  let p = ref 1 in t.arr.(0) <- 2;
  while 2 * !p + 1 <= max do
    let next = t.arr.(!p) / 2 in
    if next <= t.max_arr then
      if t.arr.(next) < 0 then t.arr.(!p) <- - t.arr.(next)
      else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := next end
    else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := t.max_arr + 1 end
  done;
  Array.sub t.arr 0 !cnt
\end{ocaml}
\caption{Un code OCaml du crible d'Euler.}
\label{fig:codeOCaml}
\end{figure}

\section{Une vérification formelle avec Why3}

% décrire la preuve ici, montrer les morceaux intéressants
% (dont la spec de la fonction principale)

% le lemme intéressant qui permet d'affirmer à un certain stade que tous les
% multiples d'un nombre sont bien marqués

La preuve que décrite ici a été intégralement réalisée avec l'outil
Why3~\cite{why3} et les démonstrateurs automatiques Alt-Ergo, CVC4, Z3, Eprover
et Vampire. % il faut les citer eux aussi ? et leurs version ?

La première partie de la preuve a consisté à démontrer l'algorithme sans prendre
en compte les éventuels débordements arithmétiques et avec des structures
de données simples et peu efficaces en terme de complexité spatiale.
L'étape suivante a consisté en un raffinement de la preuve établie précédemment
en cachant les structures de données naïves à l'aide de code
fantôme~\cite{ghost-code} et en liant ces structures de données à des structures
plus efficaces grâce à des invariants de liaison. Ces structures de données plus
efficaces n'étant, par la suite, accessibles qu'en utilisant des fonctions
\ocamlf{get/set}. Grâce à ces fonctions, il n'a donc pas été
nécessaire de reprouver l'intégralité de la preuve, simplement de montrer la
conservation des invariants de liaison par ces fonctions \ocamlf{get/set}.
Enfin, la dernière partie de la preuve a consisté en l'utilisation d'entiers
machine 63 bits signés tels que ceux d'OCaml, pour prouver l'absence de
débordements arithmétiques.

Premièrement, la spécification de la fonction principale du crible,
\ocamlf{euler_sieve}, est la suivante :

\begin{why3}
let euler_sieve (max: int63) : array63
  requires { max_int > max >= 3                               }
  ensures  { all_differents result result.length              }
  ensures  { forall i. 0 <= i < result.length -> prime result[i]   }
  ensures  { forall i. 2 <= i <= max -> prime i ->
                  exists j. 0 <= j < result.length /\ result[j] = i }
= ...
\end{why3}

Avec le prédicat \whyf{all_differents} qui est défini comme suit :

\begin{why3}
predicate all_differents (a: seq 'a) (n: int) =
    forall i j. 0 <= i < j < n -> a[i] <> a[j]
\end{why3}

% ET ... Je viens de me dire que la spec ne dit pas qu'on ne peut pas avoir
% de nombres premiers plus grands que la limite dans l'ensemble en résultat !



La preuve a nécessité l'écriture de 865 lignes dans le langage WhyML,
représentant 834 buts à prouver.
...

quelques éléments quantitatifs ici
- combien de lignes écrites pour les besoins de la preuve
- degré d'automatisation de la preuve
- quel temps de travail (approximativement)
- etc.

\section{Le code OCaml extrait de la preuve}

Le code extrait de la preuve à l'aide de la commande \texttt{extract} de Why3
est en réalité celui présenté à la figure~\ref{fig:codeOCaml}.
Seules quelques modifications dans l'apparence du code ont été effectuées
entre le code extrait et le code présenté.

à quoi ressemble-t-il ?
est-il efficace ?

\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    $N$ & temps de calcul & mémoire utilisée \\
    \hline\hline
    $10^6$ & 20.67 ms & 8.21 Mo \\\hline
    $10^7$ & 138.67 ms & 73 Mo \\\hline
    $10^8$ & 1.88 s & 721 Mo \\\hline
    $10^9$ & 14.50 s & 7.20 Go \\\hline
  \end{tabular}
\end{center}

\section{Conclusion}
\label{sec:conclusion}

une brève conclusion = résumé de ce qui a été présenté

perspectives
- prouver que la complexité est linéaire
- prouver un crible segmenté~\cite{crible-segmente}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Remerciements.} ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}


% Local Variables:
% compile-command: "make"
% ispell-local-dictionary: "francais"
% End:
