\documentclass[a4paper]{easychair}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{todonotes}
\usepackage{./why3lang}

% \pagestyle{empty} % pour la version finale EasyChair

\begin{document}

\title{...}
\titlerunning{...}
\author{Josué Moreau\thanks{Ce travail a été effectué dans le cadre
    d'un stage de L3 à l'Université Paris-Saclay, du 1er au 30 juin
    2020, encadré à distance par Jean-Christophe Filliâtre.}}
\authorrunning{Josué Moreau}
\institute{Université Paris-Saclay}
\maketitle

\begin{abstract}
  Dans cet article, ...
\end{abstract}

\section{Introduction}

% contexte : ce qu'est Why3 ; ce qu'est le crible d'Euler~\cite{crible-euler} ;
% pourquoi est-il intéressant d'en faire une preuve formelle

Le crible d'Euler, tout comme le crible d'Ératosthène, permet d'énumérer
l'ensemble des nombres premiers compris entre 2 et une limite donnée $N$.
Le crible d'Euler a une complexité temporelle en $O(N)$ pour énumérer tous les
nombres premiers dans l'ensemble $\{2,...,N\}$~\cite{crible-euler} alors que celui
d'Ératosthène a une complexité $O(\log\log N)$.

Le crible d'Euler est plus difficile à implémenter que le crible d'Eratosthène.
En particulier, cette difficulté provient des structures de données efficaces
et de différentes améliorations qui ont été faites afin de rendre l'algorithme
plus efficace en temps et en mémoire.
Ce subtilités d'implémentation sont autant d'occasions de faire des erreurs,
d'où la nécessité de vérifier formellement l'algorithme.

La preuve a été réalisée à l'aide de l'outil Why3.
L'intégralité de cette preuve est disponible en ligne~\cite{mapreuve}.

Cet article est organisé de la façon suivante.
La section~\ref{sec:algo} décrit l'algorithme du crible d'Euler, ainsi que son
implémentation dans le langage OCaml.
Puis, la section~\ref{sec:preuve} décrit les grandes lignes de la preuve qui a été
réalisée à l'aide de Why3.
Enfin, la section~\ref{sec:extraction} présente le code extrait par Why3 à partir
de la preuve qui a été réalisée. En particulier, nous comparons l'efficacité de
ce programme extrait avec une implémentation du crible d'Eratosthène et une du
crible d'Ératosthène segmenté.

\section{Le crible d'Euler}
\label{sec:algo}
% présentation de l'algorithme du crible d'Euler

L'algorithme du crible d'Euler prend comme unique entrée la limite $N \geq 2$ et va
renvoyer tous les nombres premiers compris entre $2$ et $N$. Il se divise en
deux parties. La première partie prend un nombre $n$ non marqué
tel que $2 \leq n \leq N$ et va marquer tous les multiples $np$ tels que
$2 \leq np \leq N$ et $p \geq n$ n'est pas marqué. Elle correspond à la fonction
\ocamlf{remove_products} de la figure~\ref{fig:codeOCaml}.
La deuxième partie de l'algorithme boucle sur un entier $n$ et appelle à chaque
tour de boucle la fonction \ocamlf{remove_products} puis affecte $n$ au plus
petit entier inférieur à la limite, non marqué et strictement supérieur à $n$
et recommence tant que $2 \leq n \leq N$.

À la fin de chaque étape de la boucle principale, tous les produits de $n$ sont
marqués. En effet, en supposant que pour tout $2 \leq k < n$, les multiples de $k$
sont déjà marqués, l'appel de \ocamlf{remove_products} marque tous les produits
$np$ tels que $p \geq n$ n'est pas marqué. Si un $p \geq n$ était déjà marqué,
alors, par définition du marquage, il existe un $i$ non marqué et $j$ tel que
$2 \leq i < n$, $2 \leq j < p$ et $ij = p$. Or, comme tous les multiples de $i$
étaient déjà marqués avant l'appel de \ocamlf{remove_products}, $ijn = pn$
a déjà été marqué, au plus tard lors de l'appel de \ocamlf{remove_products} sur
l'entier $i$.
Ainsi, l'algorithme ne marquant que les produits de nombres non marqués, il ne
marque qu'une seule fois chaque entier non premier, comme multiple de
son plus petit facteur premier. C'est là la clé de la complexité
linéaire du crible d'Euler.

% L'implémentation de l'algorithme que nous allons prouver se trouve dans la
% figure~\ref{fig:codeOCaml}. Dans celle-ci, nous utilisons une liste chaînée
% dans un tableau d'entiers pour représenter l'ensemble des entiers sur lesquels
% le crible sera appliqué.

% 1. idée d'utiliser une liste chaînée
L'implémentation de l'algorithme que nous allons prouver utilise une liste
chaînée croissante pour représenter les nombres de l'ensemble $\{2,...,N\}$.
Cette liste est importante pour que la représentation soit efficace car elle
permet d'obtenir efficacement le prochain entier
% en un temps amorti constant ?
en évitant de parcourir plus d'une fois un entier déjà marqué.
% 2. elle est simplement chaînée = un tableau next
De plus, elle est représentée dans un tableau d'entiers, elle est donc
simplement chaînée.

% 3. on marque un élément mais on le supprimera de la liste seulement
%    plus tard, quand on passera dessus (car on aura alors l'élément
%    précédent dans une variable, pour effectuer la suppression)
% 4. le marquage se fait dans ce même tableau next, en utilisant des
% valeurs négatives
Pour chaque case $i$, sa case correspondante contient un entier positif
si et seulement si l'entier $i$ est non marqué.
Ainsi, l'opération de marquage d'un entier non marqué consiste à remplacer le
contenu de la case d'index correspondant à l'entier à marquer par son opposé.
De plus, lorsqu'un nombre $i$ est non marqué, le contenu de sa case est son
suivant dans la liste chaînée.
Lors du marquage, on ne supprime pas l'entier marqué de la liste chaînée car
cela coûterait trop chère en temps, ou nécessiterait une liste doublement
chaînée. Au lieu de cela, la boucle de la fonction \ocamlf{remove_products}
utilise une variable $p$ qui représente le dernier entier visité.
Lorsqu'elle visite un nouvel entier $i$, elle marque $ni$, où $n$ est
l'entier dont on veut marquer tous les multiples.
Puis, si le nombre $i$ était marqué, elle modifie la case représentant $p$ en lui
donnait pour valeur le nombre suivant $i$. Cette opération permet à la liste
chaînée de ``sauter'' par dessus les entier déjà marqués, et donc n'examiner
qu'une seule fois chaque entier marqué.
Il est tout à fait possible de marquer le multiple $ni$ alors que $i$ est marqué,
le seul cas où cela est possible est lorsque $i$ est lui-même un multiple de $n$.

% 5. les valeurs paires ne sont pas représentées
Afin de diviser l'espace utilisé par deux, le tableau ne représente que les nombres
impairs, ainsi la case d'index $i$ du tableau représente l'entier $2i + 1$.
Pour chaque index $i$, la case $i$ contient un entier positif si et
seulement si l'entier $2i + 1$ n'est pas marqué.
De plus, si l'entier qu'elle contient est positif, il s'agit de l'entier suivant
dans la liste chaînée.

% parler de l'optimisation en espace pour la copie finale dans un tableau

L'implémentation de l'algorithme que nous allons prouver se trouve dans la
figure~\ref{fig:codeOCaml}.

\begin{figure}[tp]
\begin{ocaml}
type t = { arr: int array; max: int; max_arr: int }

let create max =
  let len_arr = (max - 1) / 2 + 1 in
  let arr = Array.make len_arr (-2) in
  for i = 1 to len_arr - 1 do
    arr.(i) <- if i = len_arr - 1 then max + 1 else 2 * i + 3
  done;
  { arr = arr; max = max; max_arr = (max - 1) / 2 }

let set_next t i v = t.arr.(i / 2) <- v
let get_next t i = if t.arr.(i / 2) < 0 then - t.arr.(i / 2) else t.arr.(i / 2)
let set_mark t i = if t.arr.(i / 2) >= 0 then t.arr.(i / 2) <- - t.arr.(i / 2)
let get_mark t i = t.arr.(i / 2) < 0
let get_max t = t.max

let remove_products t n =
  let d = get_max t / n in
  let rec loop (p: int) : unit =
    let next = get_next t p in
    if 0 <= next && next <= get_max t then begin
      if next <= d then begin
        set_mark t (n * next);
        if get_mark t next then begin set_next t p (get_next t next); loop p end
        else loop next
      end end in
  set_mark t (n * n); loop n

let euler_sieve max =
  let t = create max in
  let rec loop n =
    remove_products t n;
    let nn = get_next t n in
    if nn <= max / nn then loop nn in
  if max >= 9 then loop 3;
  let cnt = ref 1 in
  let p = ref 1 in t.arr.(0) <- 2;
  while 2 * !p + 1 <= max do
    let next = t.arr.(!p) / 2 in
    if next <= t.max_arr then
      if t.arr.(next) < 0 then t.arr.(!p) <- - t.arr.(next)
      else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := next end
    else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := t.max_arr + 1 end
  done;
  Array.sub t.arr 0 !cnt
\end{ocaml}
\caption{Un code OCaml du crible d'Euler.}
\label{fig:codeOCaml}
\end{figure}

\section{Une vérification formelle avec Why3}
\label{sec:preuve}
% décrire la preuve ici, montrer les morceaux intéressants
% (dont la spec de la fonction principale)

% le lemme intéressant qui permet d'affirmer à un certain stade que tous les
% multiples d'un nombre sont bien marqués

La preuve que décrite ici a été intégralement réalisée avec l'outil
Why3~\cite{why3} et les démonstrateurs automatiques Alt-Ergo, CVC4, Z3, Eprover
et Vampire. % il faut les citer eux aussi ? et leurs version ? pas forcément

\paragraph{Spécification.}
La spécification de la fonction principale du crible,
\ocamlf{euler_sieve}, est la suivante :

\begin{why3}
let euler_sieve (max: int63) : array63
  requires { max_int > max >= 3 }
  ensures  { forall i j. 0 <= i < j < result.length -> result[i] <> result[j] }
  ensures  { forall i. 0 <= i < result.length -> 2 <= result[i] <= max }
  ensures  { forall i. 0 <= i < result.length -> prime result[i] }
  ensures  { forall i. 2 <= i <= max -> prime i ->
                       exists j. 0 <= j < result.length /\ result[j] = i }
= ...
\end{why3}

% TODO expliquer d'où vient le prédicat "prime" (la bibliothèque
% number.Prime de Why3, déjà utilisée pour la preuve d'autres
% programmes manipulant des nombres premiers, comme le crible
% d'Ératosthène~\cite{EratostheneWhy3,KnuthPrimeNumbersWhy3})

Le prédicat \whyf{prime} provient de la bibliothèque \whyf{number.Prime}
de Why3. Il a déjà été utilisé dans les preuves d'autres programmes
manipulant des nombres premiers, comme le crible
d'Ératosthène~\cite{sieve-eratosthene-why3} ou celui de l'algorithme
des nombres premiers de Knuth~\cite{knuth-prime-numbers,knuth-prime-numbers-why3}.

% TODO plutôt 3 <= max < max_int ... oui mais faut refaire la preuve :'(

% expliquer int63 (une phrase) et array63 (une phrase)
% expliquer max_int > max
Le types \whyf{int63} est une modélisation Why3 des entiers OCaml qui sont
des entiers 63 bits signés. \whyf{array63} est le type d'un tableau indexé
par des entiers OCaml et contenant des entiers OCaml.
Afin de représenter $\{0,...,N\}$ il faut $N + 1$ cases dans un tableau.
Or, la longueur de ce tableau doit aussi être de type \whyf{int63}, ainsi
la longueur est inférieure ou égale à \whyf{max_int}. Pour respecter
cette contrainte, il faut donc que \whyf{max < max_int}.

% ET ... Je viens de me dire que la spec ne dit pas qu'on ne peut pas avoir
% de nombres premiers plus grands que la limite dans l'ensemble en résultat !

\paragraph{Vérification.}

Premièrement, le type manipulé au travers des fonction \ocamlf{euler_sieve}
et \\\ocamlf{remove_products} est le suivant :
% TODO: expliquer ce type dans la vérification
\begin{why3}
type t = {
  mutable ghost nexts: seq int;
  mutable ghost marked: seq bool;
  arr: array63;
  max: int63;
  max_arr: int63
}
\end{why3}

Les trois derniers champs sont les même que ceux du code OCaml de la
figure~\ref{fig:codeOCaml} avec le type \whyf{int63} qui représente le type
\ocamlf{int} de OCaml et \whyf{array63} qui représente \ocamlf{int array}.
La partie la plus importante de ce type consiste en les deux premiers champs,
ils s'agit de champs fantômes~\cite{ghost-code} qui n'existent que pour la preuve
et pas dans le programme.
Il s'agit de tableaux immuables mais dans des champs mutables.
\whyf{nexts} est une implémentation simple de la liste chaînée dans le tableau,
où tous les nombres sont représentés, il n'y a pas que les nombres impairs et
les nombres négatifs ne sont pas utilisés pour représenter les entiers marqués.
\whyf{marked} correspond aux entiers marqués, de même il représente tous les
nombres.
Ces champs fantômes sont liés au tableau \whyf{arr} par des invariants de
liaisons dont voici un exemple :
\begin{why3}
invariant { forall i. 0 <= i <= max_arr ->
                 Seq.get marked (2 * i + 1) <-> arr[i] < 0 }
\end{why3}
Ces champs fantômes permettent une manipulation plus simple des
structures de données dans la logique. De plus, les seuls accès à la liste
chaînée se font à l'aide de fonctions \whyf{get} et \whyf{set} telles que
celle-ci :
\begin{why3}
let get_next (t: t) (i: int63) : int63
  requires { 3 <= i <= t.max }
  requires { mod i 2 = 1 }
  ensures  { 3 <= result <= t.max + 1 }
  ensures  { result = Seq.get t.nexts i }
  ensures  { mod result 2 = 1 \/ result = t.max + 1 }
= let x = i / 2 in
  if t.arr[x] < 0 then - t.arr[x] else t.arr[x]
\end{why3}

La preuve de la fonction \whyf{remove_products} et de la boucle
principale de \whyf{euler_sieve} se fait donc sans avoir aucune connaissance
de la manière dont est implémentée la liste chaînée en réalité.
En particulier, cela a permis de se focaliser uniquement, dans un premier temps,
sur la preuve de l'algorithme avec une représentation de la liste chaînée
simple et peu efficace en mémoire.
Puis, une fois la preuve établie, il n'y a plus eu qu'a raffiner la preuve en
montrant que les fonctions \whyf{get} et \whyf{set} conservent bien les
invariants du type ci-dessus.
Il n'a donc pas été nécessaire de rétablir la preuve de \whyf{remove_products} et
de la boucle principale de \whyf{euler_sieve} pour l'implémentation
plus efficace de la liste chaînée.


La preuve a nécessité l'écriture de 748 lignes dans le langage WhyML :
507 lignes pour la spécification et 241 lignes de code.
Au total, 834 buts on été prouvés.
    % spec     code comments
    %  507      241       33 euler_sieve.mlw

    %  éventuellement intégrer les stats de why3 session info --stats

% quelques éléments quantitatifs ici
% - combien de lignes écrites pour les besoins de la preuve
% - degré d'automatisation de la preuve
% - quel temps de travail (approximativement)
% - etc.

\section{Le code OCaml extrait de la preuve}
\label{sec:extraction}

Le code extrait de la preuve à l'aide de la commande \texttt{extract} de Why3
est en réalité celui présenté à la figure~\ref{fig:codeOCaml}.
Seules quelques modifications dans l'apparence du code ont été effectuées
entre le code extrait et le code présenté.

à quoi ressemble-t-il ?
est-il efficace ?

\begin{center}
  \begin{tabular}{|c|r|r|}
    \hline
    $N$ & temps de calcul & mémoire utilisée \\
    \hline\hline
    $10^6$ &  0,022 s &      8 Mo \\\hline
    $10^7$ &  0,140 s &     73 Mo \\\hline
    $10^8$ &  1,350 s &    721 Mo \\\hline
    $10^9$ & 14,500 s & 7\,200 Mo \\\hline
  \end{tabular}
\end{center}

\section{Conclusion}
\label{sec:conclusion}

une brève conclusion = résumé de ce qui a été présenté

perspectives
- prouver que la complexité est linéaire
- prouver un crible segmenté~\cite{crible-segmente}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Remerciements.} ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}


% Local Variables:
% compile-command: "make"
% ispell-local-dictionary: "francais"
% End:
