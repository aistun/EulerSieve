\documentclass[a4paper]{easychair}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{todonotes}
\usepackage{./why3lang}

\usetikzlibrary{matrix, positioning, arrows.meta, arrows}

\tikzset{
mymat/.style={
  matrix of math nodes,
  text height=2.5ex,
  text depth=0.75ex,
  text width=3.25ex,
  align=center,
  column sep=-\pgflinewidth
  },
mymats/.style={
  mymat,
  nodes={draw,fill=#1}
  }
}

% \pagestyle{empty} % pour la version finale EasyChair

\newcommand\arr[1]{\ocamlf{arr[}#1\ocamlf{]}}
\newcommand\eqdef{\overset{\text{def}}{=}}

\begin{document}

\title{...}
\titlerunning{...}
\author{Josué Moreau\thanks{Ce travail a été effectué dans le cadre
    d'un stage de L3 à l'Université Paris-Saclay, du 1er au 30 juin
    2020, encadré à distance par Jean-Christophe Filliâtre.}}
\authorrunning{Josué Moreau}
\institute{Université Paris-Saclay}
\maketitle

\begin{abstract}
  Dans cet article, ...
\end{abstract}

\section{Introduction}

% contexte : ce qu'est Why3 ; ce qu'est le crible d'Euler~\cite{crible-euler} ;
% pourquoi est-il intéressant d'en faire une preuve formelle

Le crible d'Euler, tout comme le crible d'Ératosthène, permet d'énumérer
l'ensemble des nombres premiers compris entre 2 et une limite donnée $N$.
Le crible d'Euler a une complexité temporelle en $O(N)$ pour énumérer tous les
nombres premiers dans l'ensemble $\{2,...,N\}$~\cite{crible-euler} alors que
celui d'Ératosthène a une complexité en $O(\log\log N)$.

Le crible d'Euler est plus difficile à implémenter que le crible d'Ératosthène.
C'est d'autant plus vrai si on réalise quelques optimisations pour
rendre le crible d'Euler plus efficace en temps et en mémoire.
Ces subtilités d'implémentation sont autant d'occasions de faire des erreurs,
d'où la nécessité de vérifier formellement l'algorithme.

Dans cet article, on décrit une telle vérification réalisée à l'aide de
l'outil Why3~\cite{why3}.
% quelques généralités sur la preuve :
La preuve a été réalisée uniquement à l'aide des démonstrateurs automatiques.
Cependant, une partie de cette preuve a nécessité l'utilisation de différents
outils fournis par Why3 permettant d'aider le raisonnement des démonstrateurs
automatiques.
L'intégralité de cette preuve est disponible en ligne~\cite{mapreuve}.

Cet article est organisé de la façon suivante.
La section~\ref{sec:algo} décrit l'algorithme du crible d'Euler, ainsi que son
implémentation dans le langage OCaml.
Puis la section~\ref{sec:preuve} décrit les grandes lignes de la preuve qui a
été réalisée à l'aide de Why3.
Enfin, la section~\ref{sec:extraction} présente le code OCaml
automatiquement extrait par Why3 à partir
de la preuve qui a été réalisée. En particulier, nous comparons l'efficacité
de ce programme extrait avec des implémentations du crible d'Ératosthène et
du crible d'Ératosthène segmenté.

\section{Le crible d'Euler}
\label{sec:algo}

% présentation de l'algorithme du crible d'Euler
L'algorithme du crible d'Euler prend comme unique entrée la limite $N \geq 2$
et va renvoyer tous les nombres premiers compris entre $2$ et $N$.
Il se divise en deux parties.
La première partie prend un nombre $n$ non marqué
tel que $2 \leq n \leq N$ et va marquer tous les multiples $np$ tels que
$2 \leq np \leq N$ et $p \geq n$ n'est pas marqué.
Elle correspond à la fonction
\ocamlf{remove_products} de la figure~\ref{fig:codeOCaml}.
La deuxième partie de l'algorithme boucle sur un entier $n$ et appelle
à chaque tour de boucle la fonction \ocamlf{remove_products} puis
affecte $n$ au plus petit entier inférieur à la limite,
non marqué et strictement supérieur à $n$
et recommence tant que $2 \leq n \leq N$.

À la fin de chaque étape de la boucle principale, tous les produits de $n$
sont marqués. En effet, en supposant que pour tout $2 \leq k < n$,
les multiples de $k$ sont déjà marqués, l'appel de \ocamlf{remove_products}
marque tous les produits $np$ tels que $p \geq n$ n'est pas marqué.
Si un $p \geq n$ était déjà marqué,
alors, par définition du marquage, il existe un $i$ non marqué et $j$ tel que
$2 \leq i < n$, $2 \leq j < p$ et $ij = p$.
Or, comme tous les multiples de $i$
étaient déjà marqués avant l'appel de \ocamlf{remove_products}, $ijn = pn$
a déjà été marqué, au plus tard lors de l'appel de \ocamlf{remove_products}
sur l'entier $i$.
Ainsi, l'algorithme ne marquant que les produits de nombres non marqués, il ne
marque qu'une seule fois chaque entier non premier, comme multiple de
son plus petit facteur premier. C'est là la clé de la complexité
linéaire du crible d'Euler.

% L'implémentation de l'algorithme que nous allons prouver se trouve dans la
% figure~\ref{fig:codeOCaml}. Dans celle-ci, nous utilisons une liste chaînée
% dans un tableau d'entiers pour représenter l'ensemble des entiers sur lesquels
% le crible sera appliqué.

% 1. idée d'utiliser une liste chaînée
L'implémentation de l'algorithme que nous allons prouver utilise une liste
chaînée croissante pour représenter les nombres de l'ensemble $\{2,...,N\}$.
% 2. elle est simplement chaînée = un tableau next
Cette liste est simplement chaînée et est implémentée dans un tableau
des suivants \arr{$i$}.
Une liste chaînée est importante pour que la représentation soit efficace
car elle permet d'obtenir efficacement le prochain entier à parcourir.
% en un temps amorti constant ?
En parcourant un entier déjà marqué on retire cet entier de la liste,
ce qui permet de parcourir au plus une fois un entier déjà marqué.
% 4. le marquage se fait dans ce même tableau next, en utilisant des
% valeurs négatives
Pour chaque indice $i$, \arr{$i$} contient un entier positif
si et seulement si l'entier $i$ est non marqué.
Dans ce cas, \arr{$i$} est l'entier suivant $i$ dans la liste chaînée.
L'opération de marquage d'un entier~$i$ consiste à remplacer le
contenu de la case~$i$ par son opposé.

Voici un schéma décrivant l'état de la liste chaînée dans le tableau
\ocamlf{arr} à un moment donné pendant une exécution du crible d'Euler.
Dans celle-ci l'algorithme vient de marquer (en gris) tous les multiples
de $2$ et de $3$.
Il va commencer à marquer les multiples de $5$, en marquant les produits
de $5$ avec $5$, $7$, $11$, $13$, ...

% figure décrivant un état intermédiaire de l'algorithme

\begin{figure}[h]
\begin{tikzpicture}[>=latex]
  \matrix[mymat,anchor=west,row 1/.style={nodes=draw},
  % marquage des multiples de 2
  column 3/.style={nodes={fill=gray!70}},
  column 5/.style={nodes={fill=gray!70}},
  column 7/.style={nodes={fill=gray!70}},
  column 9/.style={nodes={fill=gray!70}},
  column 11/.style={nodes={fill=gray!70}},
  column 13/.style={nodes={fill=gray!70}},
  column 15/.style={nodes={fill=gray!70}},
  column 17/.style={nodes={fill=gray!70}},
  % marquage des multiples de 3
  column 8/.style={nodes={fill=gray!70}},
  column 14/.style={nodes={fill=gray!70}},
  ]
at (0,0)
(mat1)
{
  2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 &
  19\\
};

\node[right=0pt of mat1]
  (dots) {$\cdots$};

\begin{scope}
\draw[->, line width=0.7pt]
(mat1-1-1.south)
  .. controls ++ (0.1,-0.7) and ++(-0.1,-0.7) ..
(mat1-1-2.south);
\draw[->, line width=0.7pt]
(mat1-1-2.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(mat1-1-4.south);
\draw[->, line width=0.7pt]
(mat1-1-4.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(mat1-1-6.south);
\draw[->, line width=0.7pt]
(mat1-1-6.south)
  .. controls ++ (0.3,-0.9) and ++(-0.3,-0.9) ..
(mat1-1-10.south);
\draw[->, line width=0.7pt]
(mat1-1-10.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(mat1-1-12.south);
\draw[->, line width=0.7pt]
(mat1-1-12.south)
  .. controls ++ (0.3,-0.9) and ++(-0.3,-0.9) ..
(mat1-1-16.south);
\draw[->, line width=0.7pt]
(mat1-1-16.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(mat1-1-18.south);

% \draw[->, dashed, line width=0.7pt]
% (mat1-1-2.north)
%   .. controls ++ (0.9,0.9) and ++(-0.9,0.9) ..
%   node [above, sloped] (TextNode1) {$\times$}
% (mat1-1-2.north);
% \draw[->, dashed, line width=0.7pt]
% (mat1-1-2.north)
%   .. controls ++ (0.1,0.3) and ++(-0.1,0.3) ..
%   node [above, sloped] (TextNode2) {$\times$}
% (mat1-1-4.north);
% \draw[->, dashed, line width=0.7pt]
% (mat1-1-2.north)
% .. controls ++ (0.5,0.9) and ++(-0.5,0.9) ..
%   node [above, sloped] (TextNode3) {$\times$}
% (mat1-1-6.north);
% \draw[->, dashed, line width=0.7pt]
% (mat1-1-2.north)
% .. controls ++ (0.8,1.5) and ++(-0.8,1.5) ..
%   node [above, sloped] (TextNode4) {$\times$}
% (mat1-1-8.north);
\end{scope}
\end{tikzpicture}
\caption{Illustration de la liste chaînée}
\end{figure}

% 3. on marque un élément mais on le supprimera de la liste seulement
%    plus tard, quand on passera dessus (car on aura alors l'élément
%    précédent dans une variable, pour effectuer la suppression)
Lors du marquage, on ne supprime pas l'entier marqué de la liste chaînée car
cela coûterait trop cher en temps, ou nécessiterait une liste doublement
chaînée qui coûterait trop cher en espace.
Au lieu de cela, la boucle de la fonction \ocamlf{remove_products}
utilise une variable $p$ qui représente le dernier entier visité.
Lors d'un appel à \ocamlf{remove_products} pour barrer tous les multiples
de $n$,
la fonction va parcourir tous les $i$ non marqués au moment de l'appel de
\ocamlf{remove_products}. Il est donc important de remarquer qu'un entier $i$,
au moment où la boucle de \ocamlf{remove_products} arrive sur lui,
peut très bien
être déjà marqué. Si c'est le cas, alors il aura nécessairement été marqué par
une précédente itération de la boucle.
Lorsque la boucle de \ocamlf{remove_products} arrive sur un entier $i$,
$i$ étant réalité \arr{$p$}, elle marque $ni$.
Puis, elle modifie \arr{$p$} en lui donnant pour valeur \arr{$i$}.
Cette opération permet donc à la liste chaînée de ``sauter'' par dessus
les entier déjà marqués, et donc d'examiner au plus une fois chaque
entier marqué.

Avec ce procédé, il y a un nombre important d'entiers qui sont marqués et
qui ne seront pas réexaminés par la fonction \ocamlf{remove_products} et qui,
par conséquent, seront encore dans la liste chaînée à la fin de l'algorithme.
Il s'agit des entiers qui ont été marqués comme étant multiple d'un certain
$n$, mais dont le produit avec tous les entiers suivant $n$ dans la liste
chaînée est supérieur à la limite du crible.

% 5. les valeurs paires ne sont pas représentées
Afin de diviser l'espace utilisé par deux, le tableau \ocamlf{arr} ne
représente que les nombres
impairs. Ainsi, la case d'index $i$ du tableau représente l'entier $2i + 1$.
Enfin, on souhaite renvoyer un tableau ne contenant que les nombres premiers.
Pour cela, on pourrait commencer par compter les nombres premiers
de la liste chaînée, puis créer un tableau de cette taille et enfin y copier
les nombres premiers.
Cependant, on peut faire un peu mieux, en écrasant le début du tableau
contenant la liste chaînée avec les nombres premiers, puis en
extrayant avec \ocamlf{Array.sub} le préfixe contenant tous les nombres
premiers.

% une figure représentant le même état du tableau arr
% dans l'implémentation choisie, avec uniquement les nombres impairs

Voici un autre figure décrivant le tableau d'entiers uniquement les entiers
impairs et le marquage avec les entiers négatifs. Les multiples de $3$ et
$5$ ont déjà été marqués. L'algorithme s'apprête à éliminer les multiples de
$7$.

\begin{figure}[h]
\begin{tikzpicture}[>=latex]
  \matrix[mymat,anchor=west,row 2/.style={nodes=draw},
  row 2 column 1/.style={nodes={fill=gray!70}},
  % marquage des multiples de 3
  row 2 column 5/.style={nodes={fill=gray!70}},
  row 2 column 8/.style={nodes={fill=gray!70}},
  row 2 column 11/.style={nodes={fill=gray!70}},
  row 2 column 14/.style={nodes={fill=gray!70}},
  row 2 column 17/.style={nodes={fill=gray!70}},
  % marquage des multiples de 5
  row 2 column 13/.style={nodes={fill=gray!70}},
  row 2 column 18/.style={nodes={fill=gray!70}},
  ]
at (0,0)
(mat1)
{
  0 & 1 & 2 & 3 & 4 & 5  & 6  & 7  & 8  & 9  & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17\\
  1 & 3 & 5 & 7 & 9 & 11 & 13 & 15 & 17 & 19 & 21 & 23 & 25 & 27 & 29 & 31 & 33 & 35\\
};

\node[right=0pt of mat1]
  (dots) {$\cdots$};

\begin{scope}
\draw[->, line width=0.7pt]
(mat1-2-2.south)
  .. controls ++ (0.1,-0.5) and ++(-0.1,-0.5) ..
(mat1-2-3.south);
\draw[->, line width=0.7pt]
(mat1-2-3.south)
  .. controls ++ (0.1,-0.5) and ++(-0.1,-0.5) ..
(mat1-2-4.south);
\draw[->, line width=0.7pt]
(mat1-2-4.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(mat1-2-6.south);
\draw[->, line width=0.7pt]
(mat1-2-6.south)
  .. controls ++ (0.1,-0.5) and ++(-0.1,-0.5) ..
(mat1-2-7.south);
\draw[->, line width=0.7pt]
(mat1-2-7.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(mat1-2-9.south);
\draw[->, line width=0.7pt]
(mat1-2-9.south)
  .. controls ++ (0.1,-0.5) and ++(-0.1,-0.5) ..
(mat1-2-10.south);
\draw[->, line width=0.7pt]
(mat1-2-10.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(mat1-2-12.south);
\draw[->, line width=0.7pt]
(mat1-2-12.south)
  .. controls ++ (0.3,-0.9) and ++(-0.3,-0.9) ..
(mat1-2-15.south);
\draw[->, line width=0.7pt]
(mat1-2-15.south)
  .. controls ++ (0.1,-0.5) and ++(-0.1,-0.5) ..
(mat1-2-16.south);
\draw[-, line width=0.7pt]
(mat1-2-16.south)
  .. controls ++ (0.3,-0.7) and ++(-0.3,-0.7) ..
(13.5,-1);


\end{scope}
\end{tikzpicture}
\caption{Illustration de l'implémentation de la liste chaînée}
\end{figure}

L'implémentation de l'algorithme que nous allons prouver se trouve dans la
figure~\ref{fig:codeOCaml}. Dans celle-ci, on manipule à plusieurs reprises
un type \ocamlf{t}. Ce type contient pour premier champ le tableau
\ocamlf{arr} décrit précédemment.
Le champ \ocamlf{max} correspond à la limite donnée en
entrée au crible et le champ \ocamlf{max_arr} correspond au plus grand indice
du tableau \ocamlf{arr}, donc
$\text{\ocamlf{max_arr}} \eqdef \frac{\text{\ocamlf{max}} - 1}{2}$.
% \clearpage
\begin{figure}[tp]
\begin{ocaml}
type t = { arr: int array; max: int; max_arr: int }

let create max =
  let len_arr = (max - 1) / 2 + 1 in
  let arr = Array.make len_arr (-2) in
  for i = 1 to len_arr - 1 do
    arr.(i) <- if i = len_arr - 1 then max + 1 else 2 * i + 3
  done;
  { arr = arr; max = max; max_arr = (max - 1) / 2 }

let set_next t i v = t.arr.(i / 2) <- v
let get_next t i = if t.arr.(i / 2) < 0 then - t.arr.(i / 2) else t.arr.(i / 2)
let set_mark t i = if t.arr.(i / 2) >= 0 then t.arr.(i / 2) <- - t.arr.(i / 2)
let get_mark t i = t.arr.(i / 2) < 0
let get_max t = t.max

let remove_products t n =
  let d = get_max t / n in
  let rec loop (p: int) : unit =
    let next = get_next t p in
    if 0 <= next && next <= get_max t then begin
      if next <= d then begin
        set_mark t (n * next);
        if get_mark t next then begin set_next t p (get_next t next); loop p end
        else loop next
      end end in
  set_mark t (n * n); loop n

let euler_sieve max =
  let t = create max in
  let rec loop n =
    remove_products t n;
    let nn = get_next t n in
    if nn <= max / nn then loop nn in
  if max >= 9 then loop 3;
  let cnt = ref 1 in
  let p = ref 1 in t.arr.(0) <- 2;
  while 2 * !p + 1 <= max do
    let next = t.arr.(!p) / 2 in
    if next <= t.max_arr then
      if t.arr.(next) < 0 then t.arr.(!p) <- - t.arr.(next)
      else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := next end
    else begin t.arr.(!cnt) <- 2 * !p + 1; cnt := !cnt + 1; p := t.max_arr + 1 end
  done;
  Array.sub t.arr 0 !cnt
\end{ocaml}
\caption{Un code OCaml du crible d'Euler.}
\label{fig:codeOCaml}
\end{figure}

\section{Une vérification formelle avec Why3}
\label{sec:preuve}

La preuve que décrite ici a été intégralement réalisée avec l'outil
Why3~\cite{why3} et les démon\-strateurs automatiques Alt-Ergo, CVC4, Z3,
Eprover et Vampire.

\paragraph{Spécification.}
La spécification de la fonction principale du crible,
\ocamlf{euler_sieve}, est la suivante :

\begin{why3}
let euler_sieve (max: int63) : array63
  requires { max_int > max >= 3 }
  ensures  { forall i j. 0 <= i < j < result.length -> result[i] < result[j] }
  ensures  { forall i. 0 <= i < result.length -> 2 <= result[i] <= max }
  ensures  { forall i. 0 <= i < result.length -> prime result[i] }
  ensures  { forall i. 2 <= i <= max -> prime i ->
                  exists j. 0 <= j < result.length /\ result[j] = i }
= ...
\end{why3}

Le type \whyf{int63} est une modélisation Why3 des entiers OCaml qui sont
des entiers 63 bits signés. De même, le type \whyf{array63} est une
modélisation Why3 d'un tableau OCaml contenant des entiers OCaml.
La précondition requière que \whyf{max} ne soit pas égal au plus grand
entier. En effet, le code a besoin de stocker la valeur \whyf{max+1}
dans la dernière case du tableau signaler la fin.

La première postcondition représente le fait que les nombres
du tableau renvoyé en résultat sont écrits dans l'ordre croissant.
La postcondition suivante montre que les nombres renvoyés dans
le tableau sont tous dans l'ensemble $\{2,...,\text{\ocamlf{max}}\}$.
Enfin, les deux dernières postconditions énoncent que tous les
éléments du tableau renvoyé sont premiers et que tous les nombres premiers
compris entre $2$ et \ocamlf{max} sont dans le tableau.
Le prédicat \whyf{prime} utilisé dans ces deux dernières postconditions
provient de la bibliothèque \whyf{number.Prime} de Why3.
Il a déjà été utilisé dans les preuves d'autres programmes manipulant des
nombres premiers, comme le crible d'Ératosthène~\cite{sieve-eratosthene-why3}
ou celui de l'algorithme des
nombres premiers de Knuth~\cite{knuth-prime-numbers,knuth-prime-numbers-why3}.

% \clearpage
\paragraph{Vérification.}

% commencer par expliquer l'idée de raffinement : une commence avec
% une structure t abstraite (modélisant la liste chaînée et le
% marquage, sans connaître son implémentation), et on vérifie le
% crible avec cette structure abstraite, puis on la réalise avec les
% optimisations décrites dans la section précédente, et on prouve que
% cette réalisation est conforme à sa spécification

% TODO citer \cite{paskevich20isola} voire \cite{filliatre20jlamp}
% aux endroits opportuns

La preuve du crible d'Euler a été faite par
raffinement~\cite{paskevich20isola}, en deux temps.

La première partie de la preuve a été faite à l'aide d'un type \whyf{t}
représentant une structure abstraite.
Ce type modélisait la liste chaînée et le marquage sans en connaître
l'implémentation. Celui-ci se trouve dans le module \whyf{EulerSieve}
de la preuve et voici sa définition :
\begin{why3}
type t = private {
  mutable ghost nexts: seq int;
  mutable ghost marked: seq bool;
  max: int63;
}
\end{why3}
Le champ \whyf{nexts} modélise la liste chaînée implémentée par le
tableau \whyf{arr}. À la différence de ce dernier, cependant, tous les
nombres y sont représentés et le marquage en est absent.
Ce dernier est modélisé par le champ \whyf{marked}. Comme pour \whyf{nexts},
tous les nombres y sont représentés.
Le type \whyf{seq} utilisé pour décrire la liste chaînée et le marquage
est ici un type modélisant des séquences.
Il s'agit de tableaux immuables fournis par la bibliothèque standard
de Why3. Pour pouvoir les manipuler, il est donc nécessaire que les champs
correspondants soient mutables.
De plus, comme on peut le voir ci-dessus, les champs modélisant la liste
chaînée et le marquage sont des champs fantômes~\cite{ghost-code}.
Les champs fantômes n'existent que dans la preuve et pas dans
le programme. Il seront automatiquement supprimés par Why3 lors
de l'extraction du programme, une fois démontré, vers du code OCaml.
Ces champs fantômes sont ici très utiles puisqu'ils permettent de représenter
des structures de données simples, ce qui a pour conséquence de faciliter
la manipulation des structures de données dans la logique et, par conséquent,
de faciliter la preuve.

Des fonctions permettant de modifier ces champs ont été déclarées.
% sans être réalisées
Elles sont définies de manière abstraites dans le module \whyf{EulerSieve}.
Voici un exemple, extrait de la preuve, d'une telle fonction abstraite :
\begin{why3}
val set_mark (t: t) (i: int63) : unit
  requires { 0 <= i <= t.max }
  requires { mod i 2 = 1 }
  writes   { t.marked }
  ensures  { t.marked = (old t.marked)[i <- true] }
\end{why3}

La deuxième partie de la preuve a consisté en le raffinement du type \whyf{t}
précédemment défini. Ce raffinement se trouve dans le module
\whyf{EulerSieveImpl} qui est une implémentation du module \whyf{EulerSieve}.
La nouvelle définition du type \whyf{t} est la suivante :
\begin{why3}
type t = {
  mutable ghost nexts: seq int;
  mutable ghost marked: seq bool;
  arr: array63;
  max: int63;
  max_arr: int63
}
\end{why3}
On observe ci-dessus l'ajout des champs \whyf{arr} et \whyf{max_arr}
correspondant aux champs de même noms définis dans la section~\ref{sec:algo}.
Il s'agit donc de l'implémentation de la liste chaînée et du marquage.
Le champ \whyf{arr} est lié aux champs fantômes \whyf{nexts} et \whyf{marked}
par des invariants de liaison dont voici un extrait :
\begin{why3}
invariant { forall i. 0 <= i <= max_arr ->
                 Seq.get marked (2 * i + 1) <-> arr[i] < 0 }
\end{why3}
Les fonctions permettant de manipuler la liste chaînée et le marquage ont été
ensuite implémentées dans le module \whyf{EulerSieve}.
Il a été nécessaire, après implémentation, de montrer que celles-ci
satisfont les spécifications de leurs fonctions abstraites respectives et
conservent les invariants du type \whyf{t}, tel que l'invariant de liaison
défini ci-dessus.



La preuve a nécessité l'écriture de 749 lignes dans le langage WhyML :
508 lignes pour la spécification et 241 lignes de code.
Au total, 841 buts ont été prouvés.
Afin de démontrer le crible d'Euler, de nombreuses interactions ont été
faites pour aider les démonstrateurs automatiques.
Parmi ces interactions, de nombreux lemmes ont été énoncés et prouvés.
Des assertions ont également été écrites dans le programme.
Enfin, des transformations logiques ont  été appliquées à des buts à
de nombreuses reprises.
% spec     code comments
%  508      241       33 euler_sieve.mlw
%  éventuellement intégrer les stats de why3 session info --stats
La répartition des buts démontrés par les démonstrateurs automatiques est la
suivante :
\begin{center}
  \begin{tabular}{|c|r|r|}
    \hline
    démonstrateur & nombre de buts prouvés & temps maximum exécuté \\
    \hline\hline
    Eprover 2.4    &     7 &      0,74 s \\\hline
    Vampire 4.4.0  &     6 &      8,22 s \\\hline
    Alt-Ergo 2.3.2 &   518 &      7,85 s \\\hline
    Alt-Ergo 2.0.0 &    89 &      8,28 s \\\hline
    Z3 4.8.6       &   137 &      1,84 s \\\hline
    CVC4 1.7       &    39 &      0,34 s \\\hline
    CVC4 1.6       &    45 &      4,05 s \\\hline
  \end{tabular}
\end{center}

% quelques éléments quantitatifs ici
% - combien de lignes écrites pour les besoins de la preuve
% - degré d'automatisation de la preuve
% - quel temps de travail (approximativement)
% - etc.

\section{Le code OCaml extrait de la preuve}
\label{sec:extraction}

Une fois la démonstration terminée, il est maintenant possible d'extraire
le code OCaml du programme démontré. Ceci est fait par la commande
\texttt{extract} de Why3.
Le code OCaml obtenu après extraction est en réalité celui présenté
à la figure~\ref{fig:codeOCaml}.
Seules quelques modifications dans l'apparence du code ont été effectuées
entre le code extrait et le code présenté.
Voici, quelques mesures de temps de calcul et de la mémoire utilisée par
le code extrait :
\begin{center}
  \begin{tabular}{|c|r|r|}
    \hline
    $N$ & temps de calcul & mémoire utilisée \\
    \hline\hline
    $10^6$ &  0,022 s &      8 Mo \\\hline
    $10^7$ &  0,140 s &     73 Mo \\\hline
    $10^8$ &  1,350 s &    721 Mo \\\hline
    $10^9$ & 14,500 s & 7\,200 Mo \\\hline
  \end{tabular}
\end{center}

% a voir si un seul tableau est meilleur que deux tableaux ...

Afin de pouvoir évaluer l'efficacité de ce code, nous comparons maintenant
les temps de calculs du code extrait du crible d'Euler avec une
implémentation du crible d'Ératosthène et du crible d'Ératosthène
segmenté~\footnote{Merci à
  Jean-Christophe Filliâtre pour son implémentation du crible d'Ératosthène
  segmenté.}.
% la phrase suivante est moyennement bien exprimée mais je ne vois pas
% bien comment la reformuler ...
Concernant ce dernier, la comparaison est fournie pour permettre de donner
une idée de la différence d'efficacité, mais n'est pas exactement adaptée.
En effet, contrairement aux cribles d'Ératosthène et d'Euler, qui renvoie
un tableau contenant tous les nombres premiers, le crible d'Ératosthène
segmenté ne renvoie rien mais applique une fonction donnée sur tous les
nombres premiers compris entre $2$ et la limite fournie en argument.
% alors, mon implémentation du crible d'Ératosthène est ultra simple
% donc est-ce que la comparaison est vraiment bien faite ...
\begin{center}
  \begin{tabular}{|c|r|r|r|}
    \hline
    $N$ & crible d'Ératosthène & crible d'Euler &
    \multicolumn{1}{|p{3.1cm}|}{crible d'Ératosthène segmenté}\\
    \hline\hline
    $10^6$ &  0,033 s &  0,022 s &  0,013 s \\\hline
    $10^7$ &  0,186 s &  0,140 s &  0,039 s \\\hline
    $10^8$ &  1,970 s &  1,350 s &  0,312 s \\\hline
    $10^9$ & 21,780 s & 14,500 s &  3,390 s \\\hline
  \end{tabular}
\end{center}
% refaire le crible d'Eratosthène

\section{Conclusion}
\label{sec:conclusion}

une brève conclusion = résumé de ce qui a été présenté

perspectives
- prouver que la complexité est linéaire
- prouver un crible segmenté~\cite{crible-segmente}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Remerciements.} ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{./biblio}

\end{document}


% Local Variables:
% compile-command: "make"
% ispell-local-dictionary: "francais"
% End:

%  LocalWords:  implémentations
